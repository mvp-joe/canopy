// Go language extraction script for Canopy.
//
// Globals:
//   file_path  — path to the Go source file
//   file_id    — database ID of the file record
//   parse      — parse(path, language) → Tree
//   node_text  — node_text(node) → string
//   node_child — node_child(node, field) → child node or nil (safe wrapper)
//   query      — query(pattern, node) → [{capture_name: node, ...}, ...]
//   insert_symbol, insert_scope, insert_reference, insert_import,
//   insert_type_member, insert_function_param, insert_type_param
//   symbols_by_name, symbols_by_file
//   log        — log.Info(msg), log.Warn(msg), log.Error(msg)

import filepath
import strings

// ========== All function definitions first (Risor requires define-before-use) ==========

func is_exported(name) {
  if len(name) == 0 {
    return false
  }
  ch := name[0]
  return ch >= "A" && ch <= "Z"
}

func visibility(name) {
  return is_exported(name) ? "public" : "private"
}

func start_line(node) {
  return int(node.StartPoint().Row)
}

func start_col(node) {
  return int(node.StartPoint().Column)
}

func end_line(node) {
  return int(node.EndPoint().Row)
}

func end_col(node) {
  return int(node.EndPoint().Column)
}

func find_symbol_id(name, symbol_map) {
  // Check in-memory map first (for batched writes)
  if name in symbol_map {
    return symbol_map[name]
  }
  // Fallback to database query (for cross-file references)
  syms := symbols_by_file(file_id)
  for _, s := range syms {
    if s["name"] == name {
      return s["id"]
    }
  }
  return nil
}

func find_innermost_scope_id(scope_map, line, col) {
  best_id := nil
  best_size := -1
  for _, sc := range scope_map {
    sl := sc["start_line"]
    sc_col := sc["start_col"]
    el := sc["end_line"]
    ec := sc["end_col"]
    inside := false
    if line > sl && line < el {
      inside = true
    } else if line == sl && line == el {
      inside = col >= sc_col && col <= ec
    } else if line == sl {
      inside = col >= sc_col
    } else if line == el {
      inside = col <= ec
    }
    if inside {
      size := (el - sl) * 10000 + (ec - sc_col)
      if best_id == nil || size < best_size {
        best_id = sc["id"]
        best_size = size
      }
    }
  }
  return best_id
}

func insert_ref_with_scope(name, context, node, scope_map) {
  ref := {
    file_id: file_id,
    name: name,
    context: context,
    start_line: start_line(node),
    start_col: start_col(node),
    end_line: end_line(node),
    end_col: end_col(node),
  }
  sid := find_innermost_scope_id(scope_map, start_line(node), start_col(node))
  if sid != nil {
    ref["scope_id"] = sid
  }
  insert_reference(ref)
}

func extract_base_type_name(type_node) {
  t := type_node.Type()
  if t == "pointer_type" {
    inner := type_node.NamedChild(0)
    if inner != nil {
      return extract_base_type_name(inner)
    }
  } else if t == "type_identifier" {
    return node_text(type_node)
  } else if t == "qualified_type" {
    nn := node_child(type_node, "name")
    if nn != nil {
      return node_text(nn)
    }
  }
  return node_text(type_node)
}

func extract_receiver_type_name(receiver_node) {
  count := int(receiver_node.NamedChildCount())
  for i := 0; i < count; i++ {
    param := receiver_node.NamedChild(i)
    if param.Type() != "parameter_declaration" {
      continue
    }
    tn := node_child(param, "type")
    if tn == nil {
      continue
    }
    return extract_base_type_name(tn)
  }
  return ""
}

func extract_params(sym_id, params_node, is_receiver) {
  count := int(params_node.NamedChildCount())
  ordinal := 0
  for i := 0; i < count; i++ {
    param := params_node.NamedChild(i)
    if param.Type() != "parameter_declaration" {
      continue
    }

    tn := node_child(param, "type")
    type_expr := ""
    if tn != nil {
      type_expr = node_text(tn)
    }

    // Use a query to find ALL name children — handles Go shorthand
    // syntax like "a, b int" where one parameter_declaration has
    // multiple name fields.
    name_matches := query("(parameter_declaration name: (identifier) @name)", param)
    if len(name_matches) > 0 {
      for _, nm := range name_matches {
        insert_function_param({
          symbol_id: sym_id,
          name: node_text(nm["name"]),
          ordinal: ordinal,
          type_expr: type_expr,
          is_receiver: is_receiver,
          is_return: false,
        })
        ordinal = ordinal + 1
      }
    } else {
      // Unnamed parameter (e.g., just a type with no name).
      insert_function_param({
        symbol_id: sym_id,
        name: "",
        ordinal: ordinal,
        type_expr: type_expr,
        is_receiver: is_receiver,
        is_return: false,
      })
      ordinal = ordinal + 1
    }
  }
}

func extract_return_types(sym_id, result_node) {
  result_type := result_node.Type()
  if result_type == "parameter_list" {
    count := int(result_node.NamedChildCount())
    for i := 0; i < count; i++ {
      param := result_node.NamedChild(i)
      if param.Type() != "parameter_declaration" {
        continue
      }
      tn := node_child(param, "type")
      type_expr := ""
      if tn != nil {
        type_expr = node_text(tn)
      }
      nn := node_child(param, "name")
      param_name := ""
      if nn != nil {
        param_name = node_text(nn)
      }
      insert_function_param({
        symbol_id: sym_id,
        name: param_name,
        ordinal: i,
        type_expr: type_expr,
        is_receiver: false,
        is_return: true,
      })
    }
  } else {
    insert_function_param({
      symbol_id: sym_id,
      name: "",
      ordinal: 0,
      type_expr: node_text(result_node),
      is_receiver: false,
      is_return: true,
    })
  }
}

func extract_type_params(sym_id, container_node) {
  tp_matches := query("(type_parameter_list (type_parameter_declaration) @tp)", container_node)
  ordinal := 0
  for _, tp := range tp_matches {
    tp_node := tp["tp"]
    tp_nn := node_child(tp_node, "name")
    tp_tn := node_child(tp_node, "type")
    if tp_nn != nil {
      tp_name := node_text(tp_nn)
      constraint := ""
      if tp_tn != nil {
        constraint = node_text(tp_tn)
      }
      insert_type_param({
        symbol_id: sym_id,
        name: tp_name,
        ordinal: ordinal,
        param_kind: "type",
        constraints: constraint,
      })
      ordinal = ordinal + 1
    }
  }
}

func extract_block_scopes(node, parent_scope_id, scope_map) {
  block_types := ["if_statement", "for_statement", "switch_statement",
                   "select_statement", "expression_switch_statement"]
  count := int(node.NamedChildCount())
  for i := 0; i < count; i++ {
    child := node.NamedChild(i)
    child_type := child.Type()

    found := false
    for _, bt := range block_types {
      if child_type == bt {
        found = true
        break
      }
    }

    if found {
      block_scope_id := insert_scope({
        file_id: file_id,
        kind: "block",
        start_line: start_line(child),
        start_col: start_col(child),
        end_line: end_line(child),
        end_col: end_col(child),
        parent_scope_id: parent_scope_id,
      })
      scope_map[string(block_scope_id)] = {
        id: block_scope_id,
        start_line: start_line(child),
        start_col: start_col(child),
        end_line: end_line(child),
        end_col: end_col(child),
      }
      extract_block_scopes(child, block_scope_id, scope_map)
    } else {
      extract_block_scopes(child, parent_scope_id, scope_map)
    }
  }
}

// ========== Extraction pipeline ==========

tree := parse(file_path, "go")
root := tree.RootNode()

// Track symbol IDs for later reference (needed for batched writes)
symbol_ids := {}

// --- Package ---
pkg_matches := query("(package_clause (package_identifier) @name)", root)
for _, m := range pkg_matches {
  pkg_node := m["name"]
  name := node_text(pkg_node)
  sym_id := insert_symbol({
    file_id: file_id,
    name: name,
    kind: "package",
    visibility: "public",
    start_line: start_line(pkg_node),
    start_col: start_col(pkg_node),
    end_line: end_line(pkg_node),
    end_col: end_col(pkg_node),
  })
  symbol_ids[name] = sym_id
}

// --- Imports ---
import_matches := query("(import_spec path: (interpreted_string_literal) @path) @spec", root)
for _, m := range import_matches {
  spec_node := m["spec"]
  path_node := m["path"]

  raw_path := node_text(path_node)
  source := strings.trim(raw_path, "\"")

  imported_name := filepath.base(source)

  alias := ""
  alias_node := node_child(spec_node, "name")
  if alias_node != nil {
    alias = node_text(alias_node)
    if alias == "." {
      imported_name = ""
      alias = "."
    } else if alias == "_" {
      imported_name = ""
      alias = "_"
    }
  }

  imp := {
    file_id: file_id,
    source: source,
    imported_name: imported_name,
    kind: "module",
    scope: "file",
  }
  if alias != "" {
    imp["local_alias"] = alias
  }
  insert_import(imp)
}

// --- Type declarations (struct, interface, type alias) ---
type_matches := query("(type_declaration (type_spec name: (type_identifier) @name type: (_) @type) @spec) @decl", root)
for _, m := range type_matches {
  name_node := m["name"]
  type_node := m["type"]
  decl_node := m["decl"]
  spec_node := m["spec"]
  name := node_text(name_node)
  type_type := type_node.Type()

  kind := "type_alias"
  if type_type == "struct_type" {
    kind = "struct"
  } else if type_type == "interface_type" {
    kind = "interface"
  }

  sym_id := insert_symbol({
    file_id: file_id,
    name: name,
    kind: kind,
    visibility: visibility(name),
    start_line: start_line(decl_node),
    start_col: start_col(decl_node),
    end_line: end_line(decl_node),
    end_col: end_col(decl_node),
  })
  symbol_ids[name] = sym_id

  if kind == "struct" {
    field_matches := query("(field_declaration_list (field_declaration) @field)", type_node)
    for _, fm := range field_matches {
      field_node := fm["field"]
      f_nn := node_child(field_node, "name")
      f_tn := node_child(field_node, "type")

      if f_nn != nil {
        field_name := node_text(f_nn)
        field_type := ""
        if f_tn != nil {
          field_type = node_text(f_tn)
        }
        insert_type_member({
          symbol_id: sym_id,
          name: field_name,
          kind: "field",
          type_expr: field_type,
          visibility: visibility(field_name),
        })
      } else if f_tn != nil {
        embed_text := node_text(f_tn)
        insert_type_member({
          symbol_id: sym_id,
          name: embed_text,
          kind: "embedded",
          type_expr: embed_text,
          visibility: visibility(embed_text),
        })
      }
    }
  }

  if kind == "interface" {
    iface_method_matches := query("(method_elem name: (field_identifier) @name parameters: (parameter_list) @params) @method", type_node)
    for _, mm := range iface_method_matches {
      method_name := node_text(mm["name"])
      method_type := node_text(mm["method"])
      insert_type_member({
        symbol_id: sym_id,
        name: method_name,
        kind: "method",
        type_expr: method_type,
        visibility: visibility(method_name),
      })
    }

    embed_matches := query("(interface_type (type_elem (type_identifier) @name))", type_node)
    for _, em := range embed_matches {
      embed_name := node_text(em["name"])
      insert_type_member({
        symbol_id: sym_id,
        name: embed_name,
        kind: "embedded",
        type_expr: embed_name,
        visibility: visibility(embed_name),
      })
    }
  }

  extract_type_params(sym_id, spec_node)
}

// --- Function declarations ---
func_matches := query("(function_declaration name: (identifier) @name parameters: (parameter_list) @params) @func", root)
for _, m := range func_matches {
  name_node := m["name"]
  func_node := m["func"]
  params_node := m["params"]
  name := node_text(name_node)

  sym_id := insert_symbol({
    file_id: file_id,
    name: name,
    kind: "function",
    visibility: visibility(name),
    start_line: start_line(func_node),
    start_col: start_col(func_node),
    end_line: end_line(func_node),
    end_col: end_col(func_node),
  })
  symbol_ids[name] = sym_id

  extract_params(sym_id, params_node, false)

  result_node := node_child(func_node, "result")
  if result_node != nil {
    extract_return_types(sym_id, result_node)
  }

  extract_type_params(sym_id, func_node)
}

// --- Method declarations ---
method_matches := query("(method_declaration receiver: (parameter_list) @receiver name: (field_identifier) @name parameters: (parameter_list) @params) @method", root)
for _, m := range method_matches {
  name_node := m["name"]
  method_node := m["method"]
  params_node := m["params"]
  receiver_node := m["receiver"]
  name := node_text(name_node)

  receiver_type_name := extract_receiver_type_name(receiver_node)
  parent_id := nil
  if receiver_type_name != "" {
    parent_id = find_symbol_id(receiver_type_name, symbol_ids)
  }

  sym_map := {
    file_id: file_id,
    name: name,
    kind: "method",
    visibility: visibility(name),
    start_line: start_line(method_node),
    start_col: start_col(method_node),
    end_line: end_line(method_node),
    end_col: end_col(method_node),
  }
  if parent_id != nil {
    sym_map["parent_symbol_id"] = parent_id
  }

  sym_id := insert_symbol(sym_map)
  symbol_ids[name] = sym_id

  extract_params(sym_id, receiver_node, true)
  extract_params(sym_id, params_node, false)

  result_node := node_child(method_node, "result")
  if result_node != nil {
    extract_return_types(sym_id, result_node)
  }
}

// --- Variable declarations ---
var_matches := query("(var_declaration (var_spec name: (identifier) @name) @spec) @decl", root)
for _, m := range var_matches {
  name_node := m["name"]
  decl_node := m["decl"]
  name := node_text(name_node)
  sym_id := insert_symbol({
    file_id: file_id,
    name: name,
    kind: "variable",
    visibility: visibility(name),
    start_line: start_line(decl_node),
    start_col: start_col(decl_node),
    end_line: end_line(decl_node),
    end_col: end_col(decl_node),
  })
  symbol_ids[name] = sym_id
}

short_var_matches := query("(short_var_declaration left: (expression_list (identifier) @name)) @decl", root)
for _, m := range short_var_matches {
  name_node := m["name"]
  decl_node := m["decl"]
  name := node_text(name_node)
  sym_id := insert_symbol({
    file_id: file_id,
    name: name,
    kind: "variable",
    visibility: visibility(name),
    start_line: start_line(decl_node),
    start_col: start_col(decl_node),
    end_line: end_line(decl_node),
    end_col: end_col(decl_node),
  })
  symbol_ids[name] = sym_id
}

// --- Constant declarations ---
const_matches := query("(const_declaration (const_spec name: (identifier) @name) @spec) @decl", root)
for _, m := range const_matches {
  name_node := m["name"]
  decl_node := m["decl"]
  name := node_text(name_node)
  sym_id := insert_symbol({
    file_id: file_id,
    name: name,
    kind: "constant",
    visibility: visibility(name),
    start_line: start_line(decl_node),
    start_col: start_col(decl_node),
    end_line: end_line(decl_node),
    end_col: end_col(decl_node),
  })
  symbol_ids[name] = sym_id
}

// --- Scope tree ---
scope_map := {}
file_scope_id := insert_scope({
  file_id: file_id,
  kind: "file",
  start_line: start_line(root),
  start_col: start_col(root),
  end_line: end_line(root),
  end_col: end_col(root),
})
scope_map[string(file_scope_id)] = {
  id: file_scope_id,
  start_line: start_line(root),
  start_col: start_col(root),
  end_line: end_line(root),
  end_col: end_col(root),
}

fn_scope_matches := query("(function_declaration) @fn", root)
for _, m := range fn_scope_matches {
  fn_node := m["fn"]
  fn_nn := node_child(fn_node, "name")
  fn_sym_id := nil
  if fn_nn != nil {
    fn_sym_id = find_symbol_id(node_text(fn_nn), symbol_ids)
  }
  scope_data := {
    file_id: file_id,
    kind: "function",
    start_line: start_line(fn_node),
    start_col: start_col(fn_node),
    end_line: end_line(fn_node),
    end_col: end_col(fn_node),
    parent_scope_id: file_scope_id,
  }
  if fn_sym_id != nil {
    scope_data["symbol_id"] = fn_sym_id
  }
  fn_scope_id := insert_scope(scope_data)
  scope_map[string(fn_scope_id)] = {
    id: fn_scope_id,
    start_line: start_line(fn_node),
    start_col: start_col(fn_node),
    end_line: end_line(fn_node),
    end_col: end_col(fn_node),
  }
  body_node := node_child(fn_node, "body")
  if body_node != nil {
    extract_block_scopes(body_node, fn_scope_id, scope_map)
  }
}

meth_scope_matches := query("(method_declaration) @fn", root)
for _, m := range meth_scope_matches {
  fn_node := m["fn"]
  fn_nn := node_child(fn_node, "name")
  fn_sym_id := nil
  if fn_nn != nil {
    fn_sym_id = find_symbol_id(node_text(fn_nn), symbol_ids)
  }
  scope_data := {
    file_id: file_id,
    kind: "function",
    start_line: start_line(fn_node),
    start_col: start_col(fn_node),
    end_line: end_line(fn_node),
    end_col: end_col(fn_node),
    parent_scope_id: file_scope_id,
  }
  if fn_sym_id != nil {
    scope_data["symbol_id"] = fn_sym_id
  }
  fn_scope_id := insert_scope(scope_data)
  scope_map[string(fn_scope_id)] = {
    id: fn_scope_id,
    start_line: start_line(fn_node),
    start_col: start_col(fn_node),
    end_line: end_line(fn_node),
    end_col: end_col(fn_node),
  }
  body_node := node_child(fn_node, "body")
  if body_node != nil {
    extract_block_scopes(body_node, fn_scope_id, scope_map)
  }
}

// --- References ---

// Simple function calls
call_matches := query("(call_expression function: (identifier) @name) @call", root)
for _, m := range call_matches {
  insert_ref_with_scope(node_text(m["name"]), "call", m["name"], scope_map)
}

// Qualified calls: fmt.Println
sel_call_matches := query("(call_expression function: (selector_expression operand: (identifier) @operand field: (field_identifier) @field))", root)
for _, m := range sel_call_matches {
  insert_ref_with_scope(node_text(m["operand"]), "call", m["operand"], scope_map)
  insert_ref_with_scope(node_text(m["field"]), "field_access", m["field"], scope_map)
}

// Non-call selector expressions (field access only when not part of a call)
field_sel_matches := query("(selector_expression operand: (identifier) @operand field: (field_identifier) @field) @sel", root)
for _, m := range field_sel_matches {
  sel_node := m["sel"]
  parent := sel_node.Parent()
  if parent != nil && parent.Type() == "call_expression" {
    // Already handled above
  } else {
    insert_ref_with_scope(node_text(m["field"]), "field_access", m["field"], scope_map)
  }
}

// Type references (type_identifier not in declaration position)
type_ref_matches := query("(type_identifier) @type_id", root)
for _, m := range type_ref_matches {
  tn := m["type_id"]
  type_name := node_text(tn)

  parent := tn.Parent()
  is_decl := false
  if parent != nil && parent.Type() == "type_spec" {
    p_name := node_child(parent, "name")
    if p_name != nil && node_text(p_name) == type_name {
      is_decl = true
    }
  }

  if !is_decl {
    insert_ref_with_scope(type_name, "type_annotation", tn, scope_map)
  }
}
