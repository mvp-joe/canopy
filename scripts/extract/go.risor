// Go language extraction script for Canopy.
//
// Globals:
//   file_path  — path to the Go source file
//   file_id    — database ID of the file record
//   parse      — parse(path, language) → Tree
//   node_text  — node_text(node) → string
//   node_child — node_child(node, field) → child node or nil (safe wrapper)
//   query      — query(pattern, node) → [{capture_name: node, ...}, ...]
//   insert_symbol, insert_scope, insert_reference, insert_import,
//   insert_type_member, insert_function_param, insert_type_param
//   symbols_by_name, symbols_by_file
//   log        — log.Info(msg), log.Warn(msg), log.Error(msg)

import strings

// ========== All function definitions first (Risor requires define-before-use) ==========

func is_exported(name) {
  if len(name) == 0 {
    return false
  }
  ch := name[0]
  return ch >= "A" && ch <= "Z"
}

func visibility(name) {
  return is_exported(name) ? "public" : "private"
}

func start_line(node) {
  return int(node.StartPoint().Row) + 1
}

func start_col(node) {
  return int(node.StartPoint().Column)
}

func end_line(node) {
  return int(node.EndPoint().Row) + 1
}

func end_col(node) {
  return int(node.EndPoint().Column)
}

func find_symbol_id(name) {
  syms := symbols_by_file(file_id)
  for _, s := range syms {
    if s["name"] == name {
      return s["id"]
    }
  }
  return nil
}

func extract_base_type_name(type_node) {
  t := type_node.Type()
  if t == "pointer_type" {
    inner := type_node.NamedChild(0)
    if inner != nil {
      return extract_base_type_name(inner)
    }
  } else if t == "type_identifier" {
    return node_text(type_node)
  } else if t == "qualified_type" {
    nn := node_child(type_node, "name")
    if nn != nil {
      return node_text(nn)
    }
  }
  return node_text(type_node)
}

func extract_receiver_type_name(receiver_node) {
  count := int(receiver_node.NamedChildCount())
  for i := 0; i < count; i++ {
    param := receiver_node.NamedChild(i)
    if param.Type() != "parameter_declaration" {
      continue
    }
    tn := node_child(param, "type")
    if tn == nil {
      continue
    }
    return extract_base_type_name(tn)
  }
  return ""
}

func extract_params(sym_id, params_node, is_receiver) {
  count := int(params_node.NamedChildCount())
  ordinal := 0
  for i := 0; i < count; i++ {
    param := params_node.NamedChild(i)
    if param.Type() != "parameter_declaration" {
      continue
    }

    tn := node_child(param, "type")
    type_expr := ""
    if tn != nil {
      type_expr = node_text(tn)
    }

    nn := node_child(param, "name")
    if nn != nil {
      insert_function_param({
        symbol_id: sym_id,
        name: node_text(nn),
        ordinal: ordinal,
        type_expr: type_expr,
        is_receiver: is_receiver,
        is_return: false,
      })
      ordinal = ordinal + 1
    } else {
      insert_function_param({
        symbol_id: sym_id,
        name: "",
        ordinal: ordinal,
        type_expr: type_expr,
        is_receiver: is_receiver,
        is_return: false,
      })
      ordinal = ordinal + 1
    }
  }
}

func extract_return_types(sym_id, result_node) {
  result_type := result_node.Type()
  if result_type == "parameter_list" {
    count := int(result_node.NamedChildCount())
    for i := 0; i < count; i++ {
      param := result_node.NamedChild(i)
      if param.Type() != "parameter_declaration" {
        continue
      }
      tn := node_child(param, "type")
      type_expr := ""
      if tn != nil {
        type_expr = node_text(tn)
      }
      nn := node_child(param, "name")
      param_name := ""
      if nn != nil {
        param_name = node_text(nn)
      }
      insert_function_param({
        symbol_id: sym_id,
        name: param_name,
        ordinal: i,
        type_expr: type_expr,
        is_receiver: false,
        is_return: true,
      })
    }
  } else {
    insert_function_param({
      symbol_id: sym_id,
      name: "",
      ordinal: 0,
      type_expr: node_text(result_node),
      is_receiver: false,
      is_return: true,
    })
  }
}

func extract_type_params(sym_id, container_node) {
  tp_matches := query("(type_parameter_list (type_parameter_declaration) @tp)", container_node)
  ordinal := 0
  for _, tp := range tp_matches {
    tp_node := tp["tp"]
    tp_nn := node_child(tp_node, "name")
    tp_tn := node_child(tp_node, "type")
    if tp_nn != nil {
      tp_name := node_text(tp_nn)
      constraint := ""
      if tp_tn != nil {
        constraint = node_text(tp_tn)
      }
      insert_type_param({
        symbol_id: sym_id,
        name: tp_name,
        ordinal: ordinal,
        param_kind: "type",
        constraints: constraint,
      })
      ordinal = ordinal + 1
    }
  }
}

func extract_block_scopes(node, parent_scope_id) {
  block_types := ["if_statement", "for_statement", "switch_statement",
                   "select_statement", "expression_switch_statement"]
  count := int(node.NamedChildCount())
  for i := 0; i < count; i++ {
    child := node.NamedChild(i)
    child_type := child.Type()

    found := false
    for _, bt := range block_types {
      if child_type == bt {
        found = true
        break
      }
    }

    if found {
      block_scope_id := insert_scope({
        file_id: file_id,
        kind: "block",
        start_line: start_line(child),
        start_col: start_col(child),
        end_line: end_line(child),
        end_col: end_col(child),
        parent_scope_id: parent_scope_id,
      })
      extract_block_scopes(child, block_scope_id)
    } else {
      extract_block_scopes(child, parent_scope_id)
    }
  }
}

// ========== Extraction pipeline ==========

tree := parse(file_path, "go")
root := tree.RootNode()

// --- Package ---
pkg_matches := query("(package_clause (package_identifier) @name)", root)
for _, m := range pkg_matches {
  pkg_node := m["name"]
  insert_symbol({
    file_id: file_id,
    name: node_text(pkg_node),
    kind: "package",
    visibility: "public",
    start_line: start_line(pkg_node),
    start_col: start_col(pkg_node),
    end_line: end_line(pkg_node),
    end_col: end_col(pkg_node),
  })
}

// --- Imports ---
import_matches := query("(import_spec path: (interpreted_string_literal) @path) @spec", root)
for _, m := range import_matches {
  spec_node := m["spec"]
  path_node := m["path"]

  raw_path := node_text(path_node)
  source := raw_path[1:len(raw_path)-1]

  parts := strings.split(source, "/")
  imported_name := parts[len(parts)-1]

  alias := ""
  alias_node := node_child(spec_node, "name")
  if alias_node != nil {
    alias = node_text(alias_node)
    if alias == "." {
      imported_name = ""
      alias = "."
    } else if alias == "_" {
      imported_name = ""
      alias = "_"
    }
  }

  imp := {
    file_id: file_id,
    source: source,
    imported_name: imported_name,
    kind: "module",
    scope: "file",
  }
  if alias != "" {
    imp["local_alias"] = alias
  }
  insert_import(imp)
}

// --- Type declarations (struct, interface, type alias) ---
type_matches := query("(type_declaration (type_spec name: (type_identifier) @name type: (_) @type) @spec) @decl", root)
for _, m := range type_matches {
  name_node := m["name"]
  type_node := m["type"]
  decl_node := m["decl"]
  spec_node := m["spec"]
  name := node_text(name_node)
  type_type := type_node.Type()

  kind := "type_alias"
  if type_type == "struct_type" {
    kind = "struct"
  } else if type_type == "interface_type" {
    kind = "interface"
  }

  sym_id := insert_symbol({
    file_id: file_id,
    name: name,
    kind: kind,
    visibility: visibility(name),
    start_line: start_line(decl_node),
    start_col: start_col(decl_node),
    end_line: end_line(decl_node),
    end_col: end_col(decl_node),
  })

  if kind == "struct" {
    field_matches := query("(field_declaration_list (field_declaration) @field)", type_node)
    for _, fm := range field_matches {
      field_node := fm["field"]
      f_nn := node_child(field_node, "name")
      f_tn := node_child(field_node, "type")

      if f_nn != nil {
        field_name := node_text(f_nn)
        field_type := ""
        if f_tn != nil {
          field_type = node_text(f_tn)
        }
        insert_type_member({
          symbol_id: sym_id,
          name: field_name,
          kind: "field",
          type_expr: field_type,
          visibility: visibility(field_name),
        })
      } else if f_tn != nil {
        embed_text := node_text(f_tn)
        insert_type_member({
          symbol_id: sym_id,
          name: embed_text,
          kind: "embedded",
          type_expr: embed_text,
          visibility: visibility(embed_text),
        })
      }
    }
  }

  if kind == "interface" {
    iface_method_matches := query("(method_elem name: (field_identifier) @name parameters: (parameter_list) @params) @method", type_node)
    for _, mm := range iface_method_matches {
      method_name := node_text(mm["name"])
      method_type := node_text(mm["method"])
      insert_type_member({
        symbol_id: sym_id,
        name: method_name,
        kind: "method",
        type_expr: method_type,
        visibility: visibility(method_name),
      })
    }

    embed_matches := query("(interface_type (type_elem (type_identifier) @name))", type_node)
    for _, em := range embed_matches {
      embed_name := node_text(em["name"])
      insert_type_member({
        symbol_id: sym_id,
        name: embed_name,
        kind: "embedded",
        type_expr: embed_name,
        visibility: visibility(embed_name),
      })
    }
  }

  extract_type_params(sym_id, spec_node)
}

// --- Function declarations ---
func_matches := query("(function_declaration name: (identifier) @name parameters: (parameter_list) @params) @func", root)
for _, m := range func_matches {
  name_node := m["name"]
  func_node := m["func"]
  params_node := m["params"]
  name := node_text(name_node)

  sym_id := insert_symbol({
    file_id: file_id,
    name: name,
    kind: "function",
    visibility: visibility(name),
    start_line: start_line(func_node),
    start_col: start_col(func_node),
    end_line: end_line(func_node),
    end_col: end_col(func_node),
  })

  extract_params(sym_id, params_node, false)

  result_node := node_child(func_node, "result")
  if result_node != nil {
    extract_return_types(sym_id, result_node)
  }

  extract_type_params(sym_id, func_node)
}

// --- Method declarations ---
method_matches := query("(method_declaration receiver: (parameter_list) @receiver name: (field_identifier) @name parameters: (parameter_list) @params) @method", root)
for _, m := range method_matches {
  name_node := m["name"]
  method_node := m["method"]
  params_node := m["params"]
  receiver_node := m["receiver"]
  name := node_text(name_node)

  receiver_type_name := extract_receiver_type_name(receiver_node)
  parent_id := nil
  if receiver_type_name != "" {
    parent_id = find_symbol_id(receiver_type_name)
  }

  sym_map := {
    file_id: file_id,
    name: name,
    kind: "method",
    visibility: visibility(name),
    start_line: start_line(method_node),
    start_col: start_col(method_node),
    end_line: end_line(method_node),
    end_col: end_col(method_node),
  }
  if parent_id != nil {
    sym_map["parent_symbol_id"] = parent_id
  }

  sym_id := insert_symbol(sym_map)

  extract_params(sym_id, receiver_node, true)
  extract_params(sym_id, params_node, false)

  result_node := node_child(method_node, "result")
  if result_node != nil {
    extract_return_types(sym_id, result_node)
  }
}

// --- Variable declarations ---
var_matches := query("(var_declaration (var_spec name: (identifier) @name) @spec) @decl", root)
for _, m := range var_matches {
  name_node := m["name"]
  decl_node := m["decl"]
  insert_symbol({
    file_id: file_id,
    name: node_text(name_node),
    kind: "variable",
    visibility: visibility(node_text(name_node)),
    start_line: start_line(decl_node),
    start_col: start_col(decl_node),
    end_line: end_line(decl_node),
    end_col: end_col(decl_node),
  })
}

short_var_matches := query("(short_var_declaration left: (expression_list (identifier) @name)) @decl", root)
for _, m := range short_var_matches {
  name_node := m["name"]
  decl_node := m["decl"]
  insert_symbol({
    file_id: file_id,
    name: node_text(name_node),
    kind: "variable",
    visibility: visibility(node_text(name_node)),
    start_line: start_line(decl_node),
    start_col: start_col(decl_node),
    end_line: end_line(decl_node),
    end_col: end_col(decl_node),
  })
}

// --- Constant declarations ---
const_matches := query("(const_declaration (const_spec name: (identifier) @name) @spec) @decl", root)
for _, m := range const_matches {
  name_node := m["name"]
  decl_node := m["decl"]
  insert_symbol({
    file_id: file_id,
    name: node_text(name_node),
    kind: "constant",
    visibility: visibility(node_text(name_node)),
    start_line: start_line(decl_node),
    start_col: start_col(decl_node),
    end_line: end_line(decl_node),
    end_col: end_col(decl_node),
  })
}

// --- Scope tree ---
file_scope_id := insert_scope({
  file_id: file_id,
  kind: "file",
  start_line: start_line(root),
  start_col: start_col(root),
  end_line: end_line(root),
  end_col: end_col(root),
})

fn_scope_matches := query("(function_declaration) @fn", root)
for _, m := range fn_scope_matches {
  fn_node := m["fn"]
  fn_nn := node_child(fn_node, "name")
  fn_sym_id := nil
  if fn_nn != nil {
    fn_sym_id = find_symbol_id(node_text(fn_nn))
  }
  scope_map := {
    file_id: file_id,
    kind: "function",
    start_line: start_line(fn_node),
    start_col: start_col(fn_node),
    end_line: end_line(fn_node),
    end_col: end_col(fn_node),
    parent_scope_id: file_scope_id,
  }
  if fn_sym_id != nil {
    scope_map["symbol_id"] = fn_sym_id
  }
  fn_scope_id := insert_scope(scope_map)
  body_node := node_child(fn_node, "body")
  if body_node != nil {
    extract_block_scopes(body_node, fn_scope_id)
  }
}

meth_scope_matches := query("(method_declaration) @fn", root)
for _, m := range meth_scope_matches {
  fn_node := m["fn"]
  fn_nn := node_child(fn_node, "name")
  fn_sym_id := nil
  if fn_nn != nil {
    fn_sym_id = find_symbol_id(node_text(fn_nn))
  }
  scope_map := {
    file_id: file_id,
    kind: "function",
    start_line: start_line(fn_node),
    start_col: start_col(fn_node),
    end_line: end_line(fn_node),
    end_col: end_col(fn_node),
    parent_scope_id: file_scope_id,
  }
  if fn_sym_id != nil {
    scope_map["symbol_id"] = fn_sym_id
  }
  fn_scope_id := insert_scope(scope_map)
  body_node := node_child(fn_node, "body")
  if body_node != nil {
    extract_block_scopes(body_node, fn_scope_id)
  }
}

// --- References ---

// Simple function calls
call_matches := query("(call_expression function: (identifier) @name) @call", root)
for _, m := range call_matches {
  name_node := m["name"]
  insert_reference({
    file_id: file_id,
    name: node_text(name_node),
    context: "call",
    start_line: start_line(name_node),
    start_col: start_col(name_node),
    end_line: end_line(name_node),
    end_col: end_col(name_node),
  })
}

// Qualified calls: fmt.Println
sel_call_matches := query("(call_expression function: (selector_expression operand: (identifier) @operand field: (field_identifier) @field))", root)
for _, m := range sel_call_matches {
  op_node := m["operand"]
  field_node := m["field"]
  insert_reference({
    file_id: file_id,
    name: node_text(op_node),
    context: "call",
    start_line: start_line(op_node),
    start_col: start_col(op_node),
    end_line: end_line(op_node),
    end_col: end_col(op_node),
  })
  insert_reference({
    file_id: file_id,
    name: node_text(field_node),
    context: "field_access",
    start_line: start_line(field_node),
    start_col: start_col(field_node),
    end_line: end_line(field_node),
    end_col: end_col(field_node),
  })
}

// Non-call selector expressions (field access only when not part of a call)
field_sel_matches := query("(selector_expression operand: (identifier) @operand field: (field_identifier) @field) @sel", root)
for _, m := range field_sel_matches {
  sel_node := m["sel"]
  parent := sel_node.Parent()
  if parent != nil && parent.Type() == "call_expression" {
    // Already handled above
  } else {
    field_node := m["field"]
    insert_reference({
      file_id: file_id,
      name: node_text(field_node),
      context: "field_access",
      start_line: start_line(field_node),
      start_col: start_col(field_node),
      end_line: end_line(field_node),
      end_col: end_col(field_node),
    })
  }
}

// Type references (type_identifier not in declaration position)
type_ref_matches := query("(type_identifier) @type_id", root)
for _, m := range type_ref_matches {
  tn := m["type_id"]
  type_name := node_text(tn)

  parent := tn.Parent()
  is_decl := false
  if parent != nil && parent.Type() == "type_spec" {
    p_name := node_child(parent, "name")
    if p_name != nil && node_text(p_name) == type_name {
      is_decl = true
    }
  }

  if !is_decl {
    insert_reference({
      file_id: file_id,
      name: type_name,
      context: "type_annotation",
      start_line: start_line(tn),
      start_col: start_col(tn),
      end_line: end_line(tn),
      end_col: end_col(tn),
    })
  }
}
