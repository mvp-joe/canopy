// JavaScript language extraction script for Canopy.
//
// Shares most patterns with TypeScript but without:
// - Type annotations on parameters/variables
// - Interface declarations
// - Type alias declarations
// - Enum declarations
// - Type parameters (generics)
// Adds: require() imports (CommonJS)
//
// Globals:
//   file_path  — path to the JavaScript source file
//   file_id    — database ID of the file record
//   parse      — parse(path, language) → Tree
//   node_text  — node_text(node) → string
//   node_child — node_child(node, field) → child node or nil (safe wrapper)
//   query      — query(pattern, node) → [{capture_name: node, ...}, ...]
//   insert_symbol, insert_scope, insert_reference, insert_import,
//   insert_type_member, insert_function_param, insert_type_param
//   symbols_by_name, symbols_by_file
//   log        — log.Info(msg), log.Warn(msg), log.Error(msg)

import strings

// ========== All function definitions first (Risor requires define-before-use) ==========

func start_line(node) {
  return int(node.StartPoint().Row)
}

func start_col(node) {
  return int(node.StartPoint().Column)
}

func end_line(node) {
  return int(node.EndPoint().Row)
}

func end_col(node) {
  return int(node.EndPoint().Column)
}

func find_symbol_id(name, symbol_map) {
  // Check in-memory map first (for batched writes)
  if name in symbol_map {
    return symbol_map[name]
  }
  // Fallback to database query (for cross-file references)
  syms := symbols_by_file(file_id)
  for _, s := range syms {
    if s["name"] == name {
      return s["id"]
    }
  }
  return nil
}

func extract_js_params(sym_id, params_node) {
  count := int(params_node.NamedChildCount())
  ordinal := 0
  for i := 0; i < count; i++ {
    param := params_node.NamedChild(i)
    param_type := param.Type()

    param_name := ""
    has_default := false
    default_expr := ""

    if param_type == "identifier" {
      param_name = node_text(param)
    } else if param_type == "assignment_pattern" {
      // Default parameter: name = value
      left := node_child(param, "left")
      right := node_child(param, "right")
      if left != nil {
        param_name = node_text(left)
      }
      if right != nil {
        has_default = true
        default_expr = node_text(right)
      }
    } else if param_type == "rest_pattern" {
      // Rest parameter: ...args
      inner := param.NamedChild(0)
      if inner != nil {
        param_name = node_text(inner)
      }
    } else if param_type == "object_pattern" || param_type == "array_pattern" {
      // Destructured parameter — use the full pattern text as name
      param_name = node_text(param)
    }

    if param_name != "" {
      insert_function_param({
        symbol_id: sym_id,
        name: param_name,
        ordinal: ordinal,
        type_expr: "",
        is_receiver: false,
        is_return: false,
        has_default: has_default,
        default_expr: default_expr,
      })
      ordinal = ordinal + 1
    }
  }
}

func extract_block_scopes(node, parent_scope_id) {
  block_types := ["if_statement", "for_statement", "for_in_statement",
                   "while_statement", "switch_statement", "try_statement",
                   "do_statement"]
  count := int(node.NamedChildCount())
  for i := 0; i < count; i++ {
    child := node.NamedChild(i)
    child_type := child.Type()

    found := false
    for _, bt := range block_types {
      if child_type == bt {
        found = true
        break
      }
    }

    if found {
      block_scope_id := insert_scope({
        file_id: file_id,
        kind: "block",
        start_line: start_line(child),
        start_col: start_col(child),
        end_line: end_line(child),
        end_col: end_col(child),
        parent_scope_id: parent_scope_id,
      })
      extract_block_scopes(child, block_scope_id)
    } else {
      extract_block_scopes(child, parent_scope_id)
    }
  }
}

// ========== Extraction pipeline ==========

tree := parse(file_path, "javascript")
root := tree.RootNode()

// --- ES6 Imports ---
import_matches := query("(import_statement) @stmt", root)
for _, m := range import_matches {
  stmt_node := m["stmt"]

  // Get the source string
  src_matches := query("(import_statement (string (string_fragment) @src))", stmt_node)
  source := ""
  if len(src_matches) > 0 {
    source = node_text(src_matches[0]["src"])
  }
  if source == "" {
    continue
  }

  // Check for import clause
  clause_matches := query("(import_statement (import_clause) @clause)", stmt_node)
  if len(clause_matches) == 0 {
    insert_import({
      file_id: file_id,
      source: source,
      kind: "side_effect",
      scope: "file",
    })
    continue
  }

  clause := clause_matches[0]["clause"]

  // Named imports
  named_matches := query("(named_imports (import_specifier) @spec)", clause)
  for _, nm := range named_matches {
    spec := nm["spec"]
    spec_children := []
    sc := int(spec.NamedChildCount())
    for i := 0; i < sc; i++ {
      spec_children = spec_children + [spec.NamedChild(i)]
    }

    if len(spec_children) >= 2 {
      imported_name := node_text(spec_children[0])
      local_alias := node_text(spec_children[1])
      insert_import({
        file_id: file_id,
        source: source,
        imported_name: imported_name,
        local_alias: local_alias,
        kind: "named",
        scope: "file",
      })
    } else if len(spec_children) == 1 {
      imported_name := node_text(spec_children[0])
      insert_import({
        file_id: file_id,
        source: source,
        imported_name: imported_name,
        kind: "named",
        scope: "file",
      })
    }
  }

  // Namespace imports
  ns_matches := query("(namespace_import (identifier) @name)", clause)
  for _, nsm := range ns_matches {
    alias := node_text(nsm["name"])
    insert_import({
      file_id: file_id,
      source: source,
      imported_name: "*",
      local_alias: alias,
      kind: "namespace",
      scope: "file",
    })
  }

  // Default imports
  if len(named_matches) == 0 && len(ns_matches) == 0 {
    cc := int(clause.NamedChildCount())
    for i := 0; i < cc; i++ {
      ch := clause.NamedChild(i)
      if ch.Type() == "identifier" {
        insert_import({
          file_id: file_id,
          source: source,
          imported_name: node_text(ch),
          kind: "default",
          scope: "file",
        })
      }
    }
  }
}

// --- CommonJS require() imports ---
// const fs = require('fs')
// const { readFile } = require('fs')
req_matches := query("(lexical_declaration (variable_declarator value: (call_expression function: (identifier) @fn arguments: (arguments (string (string_fragment) @src)))) @decl) @stmt", root)
for _, m := range req_matches {
  fn_name := node_text(m["fn"])
  if fn_name != "require" {
    continue
  }
  source := node_text(m["src"])
  decl := m["decl"]

  // Get the name/pattern on the left side
  name_node := node_child(decl, "name")
  if name_node != nil {
    if name_node.Type() == "identifier" {
      insert_import({
        file_id: file_id,
        source: source,
        imported_name: node_text(name_node),
        kind: "require",
        scope: "file",
      })
    } else if name_node.Type() == "object_pattern" {
      // Destructured require: const { a, b } = require('...')
      pc := int(name_node.NamedChildCount())
      for i := 0; i < pc; i++ {
        ch := name_node.NamedChild(i)
        if ch.Type() == "shorthand_property_identifier_pattern" {
          insert_import({
            file_id: file_id,
            source: source,
            imported_name: node_text(ch),
            kind: "require",
            scope: "file",
          })
        }
      }
    }
  }
}

// Also catch var x = require('...') patterns
var_req_matches := query("(variable_declaration (variable_declarator value: (call_expression function: (identifier) @fn arguments: (arguments (string (string_fragment) @src)))) @decl) @stmt", root)
for _, m := range var_req_matches {
  fn_name := node_text(m["fn"])
  if fn_name != "require" {
    continue
  }
  source := node_text(m["src"])
  decl := m["decl"]

  name_node := node_child(decl, "name")
  if name_node != nil {
    if name_node.Type() == "identifier" {
      insert_import({
        file_id: file_id,
        source: source,
        imported_name: node_text(name_node),
        kind: "require",
        scope: "file",
      })
    }
  }
}

// Track symbol IDs for later reference (needed for batched writes)
symbol_ids := {}

// --- Function declarations ---
func_matches := query("(function_declaration name: (identifier) @name) @func", root)
for _, m := range func_matches {
  name_node := m["name"]
  func_node := m["func"]
  name := node_text(name_node)

  vis := "private"
  parent := func_node.Parent()
  if parent != nil && parent.Type() == "export_statement" {
    vis = "public"
  }

  sym_id := insert_symbol({
    file_id: file_id,
    name: name,
    kind: "function",
    visibility: vis,
    start_line: start_line(func_node),
    start_col: start_col(func_node),
    end_line: end_line(func_node),
    end_col: end_col(func_node),
  })
  symbol_ids[name] = sym_id

  params_node := node_child(func_node, "parameters")
  if params_node != nil {
    extract_js_params(sym_id, params_node)
  }
}

// --- Class declarations ---
class_matches := query("(class_declaration name: (identifier) @name) @class", root)
for _, m := range class_matches {
  name_node := m["name"]
  class_node := m["class"]
  name := node_text(name_node)

  vis := "private"
  parent := class_node.Parent()
  if parent != nil && parent.Type() == "export_statement" {
    vis = "public"
  }

  sym_id := insert_symbol({
    file_id: file_id,
    name: name,
    kind: "class",
    visibility: vis,
    start_line: start_line(class_node),
    start_col: start_col(class_node),
    end_line: end_line(class_node),
    end_col: end_col(class_node),
  })
  symbol_ids[name] = sym_id

  // Extract class body members
  body_matches := query("(class_body) @body", class_node)
  if len(body_matches) > 0 {
    body := body_matches[0]["body"]
    body_count := int(body.NamedChildCount())
    for i := 0; i < body_count; i++ {
      member := body.NamedChild(i)
      member_type := member.Type()

      if member_type == "method_definition" {
        meth_name := ""
        pc := int(member.NamedChildCount())
        for j := 0; j < pc; j++ {
          ch := member.NamedChild(j)
          if ch.Type() == "property_identifier" {
            meth_name = node_text(ch)
            break
          }
        }
        if meth_name != "" {
          meth_sym_id := insert_symbol({
            file_id: file_id,
            name: meth_name,
            kind: "method",
            visibility: "public",
            parent_symbol_id: sym_id,
            start_line: start_line(member),
            start_col: start_col(member),
            end_line: end_line(member),
            end_col: end_col(member),
          })

          insert_type_member({
            symbol_id: sym_id,
            name: meth_name,
            kind: "method",
            type_expr: "",
            visibility: "public",
          })

          // Extract method parameters
          meth_params := node_child(member, "parameters")
          if meth_params != nil {
            extract_js_params(meth_sym_id, meth_params)
          }
        }
      } else if member_type == "field_definition" {
        // JS class field (stage 3 proposal, widely supported)
        prop_name := ""
        pc := int(member.NamedChildCount())
        for j := 0; j < pc; j++ {
          ch := member.NamedChild(j)
          if ch.Type() == "property_identifier" {
            prop_name = node_text(ch)
            break
          }
        }
        if prop_name != "" {
          insert_type_member({
            symbol_id: sym_id,
            name: prop_name,
            kind: "property",
            type_expr: "",
            visibility: "public",
          })
        }
      }
    }
  }
}

// --- Variable and constant declarations ---
// var declarations
var_matches := query("(variable_declaration (variable_declarator name: (identifier) @name) @decl) @stmt", root)
for _, m := range var_matches {
  name_node := m["name"]
  stmt_node := m["stmt"]
  decl_node := m["decl"]
  name := node_text(name_node)

  // Skip require() declarations — already handled as imports
  val_node := node_child(decl_node, "value")
  if val_node != nil && val_node.Type() == "call_expression" {
    fn_node := node_child(val_node, "function")
    if fn_node != nil && node_text(fn_node) == "require" {
      continue
    }
  }

  vis := "private"
  parent := stmt_node.Parent()
  if parent != nil && parent.Type() == "export_statement" {
    vis = "public"
  }

  insert_symbol({
    file_id: file_id,
    name: name,
    kind: "variable",
    visibility: vis,
    start_line: start_line(stmt_node),
    start_col: start_col(stmt_node),
    end_line: end_line(stmt_node),
    end_col: end_col(stmt_node),
  })
}

// let/const declarations
lex_matches := query("(lexical_declaration (variable_declarator name: (identifier) @name) @decl) @stmt", root)
for _, m := range lex_matches {
  name_node := m["name"]
  stmt_node := m["stmt"]
  decl_node := m["decl"]
  name := node_text(name_node)

  // Skip require() declarations — already handled as imports
  val_node := node_child(decl_node, "value")
  if val_node != nil && val_node.Type() == "call_expression" {
    fn_node := node_child(val_node, "function")
    if fn_node != nil && node_text(fn_node) == "require" {
      continue
    }
  }

  raw := node_text(stmt_node)
  kind := "variable"
  if strings.has_prefix(raw, "const ") {
    kind = "constant"
  }

  vis := "private"
  parent := stmt_node.Parent()
  if parent != nil && parent.Type() == "export_statement" {
    vis = "public"
  }

  // Check if value is an arrow function
  if val_node != nil && val_node.Type() == "arrow_function" {
    sym_id := insert_symbol({
      file_id: file_id,
      name: name,
      kind: "function",
      visibility: vis,
      start_line: start_line(stmt_node),
      start_col: start_col(stmt_node),
      end_line: end_line(stmt_node),
      end_col: end_col(stmt_node),
    })

    af_params := node_child(val_node, "parameters")
    if af_params != nil {
      extract_js_params(sym_id, af_params)
    }
  } else {
    insert_symbol({
      file_id: file_id,
      name: name,
      kind: kind,
      visibility: vis,
      start_line: start_line(stmt_node),
      start_col: start_col(stmt_node),
      end_line: end_line(stmt_node),
      end_col: end_col(stmt_node),
    })
  }
}

// --- Export re-exports ---
export_matches := query("(export_statement) @export", root)
for _, m := range export_matches {
  export_node := m["export"]

  clause_matches := query("(export_statement (export_clause) @clause)", export_node)
  if len(clause_matches) > 0 {
    src_matches := query("(export_statement (string (string_fragment) @src))", export_node)
    if len(src_matches) > 0 {
      source := node_text(src_matches[0]["src"])
      spec_matches := query("(export_clause (export_specifier) @spec)", export_node)
      for _, sm := range spec_matches {
        spec := sm["spec"]
        sc := int(spec.NamedChildCount())
        if sc > 0 {
          exported_name := node_text(spec.NamedChild(0))
          insert_import({
            file_id: file_id,
            source: source,
            imported_name: exported_name,
            kind: "reexport",
            scope: "file",
          })
        }
      }
    }
  }
}

// --- Scope tree ---
file_scope_id := insert_scope({
  file_id: file_id,
  kind: "file",
  start_line: start_line(root),
  start_col: start_col(root),
  end_line: end_line(root),
  end_col: end_col(root),
})

// Function scopes
fn_scope_matches := query("(function_declaration) @fn", root)
for _, m := range fn_scope_matches {
  fn_node := m["fn"]
  fn_nn := node_child(fn_node, "name")
  fn_sym_id := nil
  if fn_nn != nil {
    fn_sym_id = find_symbol_id(node_text(fn_nn), symbol_ids)
  }
  scope_map := {
    file_id: file_id,
    kind: "function",
    start_line: start_line(fn_node),
    start_col: start_col(fn_node),
    end_line: end_line(fn_node),
    end_col: end_col(fn_node),
    parent_scope_id: file_scope_id,
  }
  if fn_sym_id != nil {
    scope_map["symbol_id"] = fn_sym_id
  }
  fn_scope_id := insert_scope(scope_map)
  body_node := node_child(fn_node, "body")
  if body_node != nil {
    extract_block_scopes(body_node, fn_scope_id)
  }
}

// Class scopes
cls_scope_matches := query("(class_declaration) @cls", root)
for _, m := range cls_scope_matches {
  cls_node := m["cls"]
  cls_nn := node_child(cls_node, "name")
  cls_sym_id := nil
  if cls_nn != nil {
    cls_sym_id = find_symbol_id(node_text(cls_nn), symbol_ids)
  }
  scope_map := {
    file_id: file_id,
    kind: "class",
    start_line: start_line(cls_node),
    start_col: start_col(cls_node),
    end_line: end_line(cls_node),
    end_col: end_col(cls_node),
    parent_scope_id: file_scope_id,
  }
  if cls_sym_id != nil {
    scope_map["symbol_id"] = cls_sym_id
  }
  insert_scope(scope_map)
}

// --- References ---

// Simple function calls
call_matches := query("(call_expression function: (identifier) @name) @call", root)
for _, m := range call_matches {
  name_node := m["name"]
  if node_text(name_node) == "require" {
    continue
  }
  insert_reference({
    file_id: file_id,
    name: node_text(name_node),
    context: "call",
    start_line: start_line(name_node),
    start_col: start_col(name_node),
    end_line: end_line(name_node),
    end_col: end_col(name_node),
  })
}

// Method calls
sel_call_matches := query("(call_expression function: (member_expression object: (identifier) @obj property: (property_identifier) @prop))", root)
for _, m := range sel_call_matches {
  obj_node := m["obj"]
  prop_node := m["prop"]
  insert_reference({
    file_id: file_id,
    name: node_text(obj_node),
    context: "call",
    start_line: start_line(obj_node),
    start_col: start_col(obj_node),
    end_line: end_line(obj_node),
    end_col: end_col(obj_node),
  })
  insert_reference({
    file_id: file_id,
    name: node_text(prop_node),
    context: "field_access",
    start_line: start_line(prop_node),
    start_col: start_col(prop_node),
    end_line: end_line(prop_node),
    end_col: end_col(prop_node),
  })
}

// Non-call field access
field_sel_matches := query("(member_expression object: (identifier) @obj property: (property_identifier) @prop) @sel", root)
for _, m := range field_sel_matches {
  sel_node := m["sel"]
  parent := sel_node.Parent()
  if parent != nil && parent.Type() == "call_expression" {
    // Already handled above
  } else {
    prop_node := m["prop"]
    insert_reference({
      file_id: file_id,
      name: node_text(prop_node),
      context: "field_access",
      start_line: start_line(prop_node),
      start_col: start_col(prop_node),
      end_line: end_line(prop_node),
      end_col: end_col(prop_node),
    })
  }
}

// new expressions
new_matches := query("(new_expression constructor: (identifier) @name)", root)
for _, m := range new_matches {
  name_node := m["name"]
  insert_reference({
    file_id: file_id,
    name: node_text(name_node),
    context: "call",
    start_line: start_line(name_node),
    start_col: start_col(name_node),
    end_line: end_line(name_node),
    end_col: end_col(name_node),
  })
}
