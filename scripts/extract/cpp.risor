// C++ language extraction script for Canopy.
//
// Globals:
//   file_path  — path to the C++ source file
//   file_id    — database ID of the file record
//   parse      — parse(path, language) → Tree
//   node_text  — node_text(node) → string
//   node_child — node_child(node, field) → child node or nil (safe wrapper)
//   query      — query(pattern, node) → [{capture_name: node, ...}, ...]
//   insert_symbol, insert_scope, insert_reference, insert_import,
//   insert_type_member, insert_function_param, insert_type_param
//   symbols_by_name, symbols_by_file
//   log        — log.Info(msg), log.Warn(msg), log.Error(msg)

import strings

// ========== All function definitions first (Risor requires define-before-use) ==========

func start_line(node) {
  return int(node.StartPoint().Row)
}

func start_col(node) {
  return int(node.StartPoint().Column)
}

func end_line(node) {
  return int(node.EndPoint().Row)
}

func end_col(node) {
  return int(node.EndPoint().Column)
}

func find_symbol_id(name) {
  syms := symbols_by_file(file_id)
  for _, s := range syms {
    if s["name"] == name {
      return s["id"]
    }
  }
  return nil
}

// extract_declarator_name walks a declarator tree to find the leaf identifier.
func extract_declarator_name(decl_node) {
  t := decl_node.Type()
  if t == "identifier" || t == "type_identifier" || t == "field_identifier" {
    return node_text(decl_node)
  }
  if t == "qualified_identifier" {
    nn := node_child(decl_node, "name")
    if nn != nil {
      return node_text(nn)
    }
  }
  if t == "destructor_name" {
    // ~ClassName — return ~ClassName
    return node_text(decl_node)
  }
  if t == "operator_name" {
    return node_text(decl_node)
  }
  if t == "pointer_declarator" || t == "parenthesized_declarator" || t == "array_declarator" || t == "reference_declarator" {
    inner := node_child(decl_node, "declarator")
    if inner != nil {
      return extract_declarator_name(inner)
    }
  }
  if t == "function_declarator" {
    inner := node_child(decl_node, "declarator")
    if inner != nil {
      return extract_declarator_name(inner)
    }
  }
  return node_text(decl_node)
}

// extract_param_name gets the name from a parameter_declaration.
func extract_param_name(param_node) {
  dn := node_child(param_node, "declarator")
  if dn == nil {
    return ""
  }
  return extract_declarator_name(dn)
}

// extract_full_param_type returns the type string from a parameter.
func extract_full_param_type(param_node) {
  type_node := node_child(param_node, "type")
  decl_node := node_child(param_node, "declarator")
  base := ""
  if type_node != nil {
    base = node_text(type_node)
  }
  if decl_node == nil {
    return base
  }
  dt := decl_node.Type()
  if dt == "pointer_declarator" || dt == "abstract_pointer_declarator" {
    return base + " *"
  }
  if dt == "reference_declarator" || dt == "abstract_reference_declarator" {
    return base + "&"
  }
  return base
}

func extract_cpp_params(sym_id, params_node) {
  count := int(params_node.NamedChildCount())
  ordinal := 0
  for i := 0; i < count; i++ {
    param := params_node.NamedChild(i)
    if param.Type() != "parameter_declaration" {
      continue
    }
    pname := extract_param_name(param)
    ptype := extract_full_param_type(param)

    insert_function_param({
      symbol_id: sym_id,
      name: pname,
      ordinal: ordinal,
      type_expr: ptype,
      is_receiver: false,
      is_return: false,
    })
    ordinal = ordinal + 1
  }
}

func extract_block_scopes(node, parent_scope_id) {
  block_types := ["if_statement", "for_statement", "while_statement",
                   "switch_statement", "do_statement", "for_range_loop",
                   "try_statement"]
  count := int(node.NamedChildCount())
  for i := 0; i < count; i++ {
    child := node.NamedChild(i)
    child_type := child.Type()

    found := false
    for _, bt := range block_types {
      if child_type == bt {
        found = true
        break
      }
    }

    if found {
      block_scope_id := insert_scope({
        file_id: file_id,
        kind: "block",
        start_line: start_line(child),
        start_col: start_col(child),
        end_line: end_line(child),
        end_col: end_col(child),
        parent_scope_id: parent_scope_id,
      })
      extract_block_scopes(child, block_scope_id)
    } else {
      extract_block_scopes(child, parent_scope_id)
    }
  }
}

// track_access_specifier finds the current access specifier for a position
// in a field_declaration_list by scanning siblings.
// Returns "public", "private", or "protected".
func get_access_at_index(body_node, target_index, default_access) {
  current := default_access
  count := int(body_node.NamedChildCount())
  for i := 0; i < count; i++ {
    if i >= target_index {
      break
    }
    child := body_node.NamedChild(i)
    if child.Type() == "access_specifier" {
      txt := node_text(child)
      if strings.has_prefix(txt, "public") {
        current = "public"
      } else if strings.has_prefix(txt, "protected") {
        current = "protected"
      } else if strings.has_prefix(txt, "private") {
        current = "private"
      }
    }
  }
  return current
}

// find_child_index returns the named-child index of a node within its parent.
func find_child_index(parent, child_node) {
  count := int(parent.NamedChildCount())
  for i := 0; i < count; i++ {
    c := parent.NamedChild(i)
    if c.StartPoint().Row == child_node.StartPoint().Row && c.StartPoint().Column == child_node.StartPoint().Column {
      return i
    }
  }
  return 0
}

// extract_class_members extracts fields, methods, constructors, destructors.
func extract_class_members(sym_id, body_node, default_access) {
  count := int(body_node.NamedChildCount())
  for i := 0; i < count; i++ {
    child := body_node.NamedChild(i)
    ct := child.Type()

    if ct == "access_specifier" {
      continue
    }

    access := get_access_at_index(body_node, i, default_access)

    if ct == "field_declaration" {
      decl_node := node_child(child, "declarator")
      type_node := node_child(child, "type")
      if decl_node == nil {
        continue
      }
      dt := decl_node.Type()
      type_text := ""
      if type_node != nil {
        type_text = node_text(type_node)
      }

      if dt == "function_declarator" {
        // This is a method declaration
        method_name_node := node_child(decl_node, "declarator")
        if method_name_node == nil {
          continue
        }
        method_name := extract_declarator_name(method_name_node)

        // Check for virtual specifier
        modifiers := ""
        vs_matches := query("(virtual_specifier) @vs", decl_node)
        for _, vsm := range vs_matches {
          modifiers = node_text(vsm["vs"])
        }

        // Check if parent declaration has "virtual" keyword
        virt_matches := query("(virtual) @v", child)
        is_virtual := len(virt_matches) > 0

        // Check for pure virtual
        pv_matches := query("(pure_virtual_clause) @pv", child)
        is_pure := len(pv_matches) > 0

        member_kind := "method"
        full_type := type_text
        if is_virtual {
          full_type = "virtual " + full_type
        }
        if is_pure {
          full_type = full_type + " = 0"
        }
        if modifiers != "" {
          full_type = full_type + " " + modifiers
        }

        insert_type_member({
          symbol_id: sym_id,
          name: method_name,
          kind: member_kind,
          type_expr: full_type,
          visibility: access,
        })
      } else {
        // Regular field
        field_name := extract_declarator_name(decl_node)
        insert_type_member({
          symbol_id: sym_id,
          name: field_name,
          kind: "field",
          type_expr: type_text,
          visibility: access,
        })
      }
    } else if ct == "declaration" {
      // Constructor or destructor declaration inside class body
      decl_node := node_child(child, "declarator")
      if decl_node == nil {
        continue
      }
      if decl_node.Type() == "function_declarator" {
        name_node := node_child(decl_node, "declarator")
        if name_node == nil {
          continue
        }
        cname := extract_declarator_name(name_node)

        // Check for virtual (destructor)
        virt_matches := query("(virtual) @v", child)
        is_virtual := len(virt_matches) > 0

        member_kind := "method"
        type_text := ""
        if is_virtual {
          type_text = "virtual"
        }

        insert_type_member({
          symbol_id: sym_id,
          name: cname,
          kind: member_kind,
          type_expr: type_text,
          visibility: access,
        })
      }
    } else if ct == "function_definition" {
      // Inline method definition or pure virtual inside class body
      fdecl := node_child(child, "declarator")
      if fdecl == nil {
        continue
      }
      name_node := node_child(fdecl, "declarator")
      if name_node == nil {
        continue
      }
      method_name := extract_declarator_name(name_node)
      type_node := node_child(child, "type")
      type_text := ""
      if type_node != nil {
        type_text = node_text(type_node)
      }

      // Check for virtual keyword
      virt_matches := query("(virtual) @v", child)
      is_virtual := len(virt_matches) > 0

      // Check for pure virtual clause (= 0)
      pv_matches := query("(pure_virtual_clause) @pv", child)
      is_pure := len(pv_matches) > 0

      // Check for override/final specifier
      modifiers := ""
      vs_matches := query("(virtual_specifier) @vs", fdecl)
      for _, vsm := range vs_matches {
        modifiers = node_text(vsm["vs"])
      }

      full_type := type_text
      if is_virtual {
        full_type = "virtual " + full_type
      }
      if is_pure {
        full_type = full_type + " = 0"
      }
      if modifiers != "" {
        full_type = full_type + " " + modifiers
      }

      insert_type_member({
        symbol_id: sym_id,
        name: method_name,
        kind: "method",
        type_expr: full_type,
        visibility: access,
      })
    }
  }
}

// ========== Extraction pipeline ==========

tree := parse(file_path, "cpp")
root := tree.RootNode()

// --- Includes ---
include_matches := query("(preproc_include) @inc", root)
for _, m := range include_matches {
  inc_node := m["inc"]
  path_node := node_child(inc_node, "path")
  if path_node == nil {
    continue
  }
  raw_path := node_text(path_node)
  source := raw_path
  if len(raw_path) >= 2 {
    first := raw_path[0]
    if first == "<" || first == "\"" {
      source = raw_path[1:len(raw_path)-1]
    }
  }

  insert_import({
    file_id: file_id,
    source: source,
    imported_name: source,
    kind: "header",
    scope: "file",
  })
}

// --- Using declarations (treated as imports) ---
using_matches := query("(using_declaration) @using", root)
for _, m := range using_matches {
  using_node := m["using"]

  // Check for qualified_identifier (using std::string)
  qi_matches := query("(qualified_identifier scope: (namespace_identifier) @ns name: (identifier) @name) @qi", using_node)
  if len(qi_matches) > 0 {
    ns_name := node_text(qi_matches[0]["ns"])
    id_name := node_text(qi_matches[0]["name"])
    insert_import({
      file_id: file_id,
      source: ns_name,
      imported_name: id_name,
      kind: "symbol",
      scope: "file",
    })
  } else {
    // using namespace std;
    id_matches := query("(identifier) @id", using_node)
    if len(id_matches) > 0 {
      ns := node_text(id_matches[0]["id"])
      insert_import({
        file_id: file_id,
        source: ns,
        imported_name: ns,
        kind: "namespace",
        scope: "file",
      })
    }
  }
}

// --- Namespace declarations ---
ns_matches := query("(namespace_definition name: (namespace_identifier) @name) @ns", root)
for _, m := range ns_matches {
  name_node := m["name"]
  ns_node := m["ns"]
  insert_symbol({
    file_id: file_id,
    name: node_text(name_node),
    kind: "namespace",
    visibility: "public",
    start_line: start_line(ns_node),
    start_col: start_col(ns_node),
    end_line: end_line(ns_node),
    end_col: end_col(ns_node),
  })
}

// --- Class declarations ---
class_matches := query("(class_specifier name: (type_identifier) @name body: (field_declaration_list) @body) @class", root)
for _, m := range class_matches {
  name_node := m["name"]
  class_node := m["class"]
  body_node := m["body"]
  name := node_text(name_node)

  // Check if this class is inside a template_declaration
  parent := class_node.Parent()
  outer := class_node
  if parent != nil && parent.Type() == "template_declaration" {
    outer = parent
  }

  sym_id := insert_symbol({
    file_id: file_id,
    name: name,
    kind: "class",
    visibility: "public",
    start_line: start_line(outer),
    start_col: start_col(outer),
    end_line: end_line(outer),
    end_col: end_col(outer),
  })

  // Extract base classes (inheritance)
  base_matches := query("(base_class_clause (type_identifier) @base)", class_node)
  for _, bm := range base_matches {
    base_name := node_text(bm["base"])
    insert_type_member({
      symbol_id: sym_id,
      name: base_name,
      kind: "embedded",
      type_expr: base_name,
      visibility: "public",
    })
  }

  // Extract members (default access for class is private)
  extract_class_members(sym_id, body_node, "private")

  // Extract template type params if wrapped in template_declaration
  if parent != nil && parent.Type() == "template_declaration" {
    tp_matches := query("(template_parameter_list (type_parameter_declaration (type_identifier) @tp_name)) @tpl", parent)
    ordinal := 0
    for _, tp := range tp_matches {
      tp_name := node_text(tp["tp_name"])
      insert_type_param({
        symbol_id: sym_id,
        name: tp_name,
        ordinal: ordinal,
        param_kind: "type",
        constraints: "",
      })
      ordinal = ordinal + 1
    }
  }
}

// --- Struct declarations (C++ structs have default public access) ---
struct_matches := query("(struct_specifier name: (type_identifier) @name body: (field_declaration_list) @body) @struct", root)
for _, m := range struct_matches {
  name_node := m["name"]
  struct_node := m["struct"]
  body_node := m["body"]
  name := node_text(name_node)

  sym_id := insert_symbol({
    file_id: file_id,
    name: name,
    kind: "struct",
    visibility: "public",
    start_line: start_line(struct_node),
    start_col: start_col(struct_node),
    end_line: end_line(struct_node),
    end_col: end_col(struct_node),
  })

  // Extract members (default access for struct is public)
  extract_class_members(sym_id, body_node, "public")
}

// --- Enum declarations (including enum class) ---
enum_matches := query("(enum_specifier name: (type_identifier) @name body: (enumerator_list) @body) @enum", root)
for _, m := range enum_matches {
  name_node := m["name"]
  enum_node := m["enum"]
  body_node := m["body"]
  name := node_text(name_node)

  sym_id := insert_symbol({
    file_id: file_id,
    name: name,
    kind: "enum",
    visibility: "public",
    start_line: start_line(enum_node),
    start_col: start_col(enum_node),
    end_line: end_line(enum_node),
    end_col: end_col(enum_node),
  })

  enumerator_matches := query("(enumerator name: (identifier) @name) @en", body_node)
  for _, em := range enumerator_matches {
    en_name := node_text(em["name"])
    insert_type_member({
      symbol_id: sym_id,
      name: en_name,
      kind: "variant",
      type_expr: "",
      visibility: "public",
    })
  }
}

// --- Typedef declarations ---
typedef_matches := query("(type_definition) @td", root)
for _, m := range typedef_matches {
  td_node := m["td"]
  decl_node := node_child(td_node, "declarator")
  type_node := node_child(td_node, "type")

  if decl_node == nil {
    continue
  }

  name := extract_declarator_name(decl_node)

  insert_symbol({
    file_id: file_id,
    name: name,
    kind: "type_alias",
    visibility: "public",
    start_line: start_line(td_node),
    start_col: start_col(td_node),
    end_line: end_line(td_node),
    end_col: end_col(td_node),
  })
}

// --- Macro definitions ---
def_matches := query("(preproc_def name: (identifier) @name) @def", root)
for _, m := range def_matches {
  name_node := m["name"]
  def_node := m["def"]
  insert_symbol({
    file_id: file_id,
    name: node_text(name_node),
    kind: "constant",
    visibility: "public",
    start_line: start_line(def_node),
    start_col: start_col(def_node),
    end_line: end_line(def_node),
    end_col: end_col(def_node),
  })
}

fndef_matches := query("(preproc_function_def name: (identifier) @name) @def", root)
for _, m := range fndef_matches {
  name_node := m["name"]
  def_node := m["def"]
  insert_symbol({
    file_id: file_id,
    name: node_text(name_node),
    kind: "function",
    visibility: "public",
    start_line: start_line(def_node),
    start_col: start_col(def_node),
    end_line: end_line(def_node),
    end_col: end_col(def_node),
  })
}

// --- Function definitions (top-level and qualified like Class::method) ---
funcdef_matches := query("(function_definition declarator: (function_declarator) @fdecl) @func", root)
for _, m := range funcdef_matches {
  func_node := m["func"]
  fdecl_node := m["fdecl"]

  // Skip if inside class/struct body (those are handled by extract_class_members)
  parent := func_node.Parent()
  if parent != nil {
    pt := parent.Type()
    if pt == "field_declaration_list" || pt == "declaration_list" {
      // Inside a class body or namespace body — skip class body but handle namespace
      grandparent := parent.Parent()
      if grandparent != nil {
        gpt := grandparent.Type()
        if gpt == "class_specifier" || gpt == "struct_specifier" {
          continue
        }
      }
    }
  }

  // Skip template-wrapped functions (handled below)
  if parent != nil && parent.Type() == "template_declaration" {
    continue
  }

  name_node := node_child(fdecl_node, "declarator")
  if name_node == nil {
    continue
  }
  name := extract_declarator_name(name_node)

  type_node := node_child(func_node, "type")
  ret_type := ""
  if type_node != nil {
    ret_type = node_text(type_node)
  }

  // Determine kind: "method" if qualified (Class::method), "function" otherwise
  kind := "function"
  parent_id := nil
  if name_node.Type() == "qualified_identifier" {
    kind = "method"
    scope_node := node_child(name_node, "scope")
    if scope_node != nil {
      parent_id = find_symbol_id(node_text(scope_node))
    }
  }

  sym_map := {
    file_id: file_id,
    name: name,
    kind: kind,
    visibility: "public",
    start_line: start_line(func_node),
    start_col: start_col(func_node),
    end_line: end_line(func_node),
    end_col: end_col(func_node),
  }
  if parent_id != nil {
    sym_map["parent_symbol_id"] = parent_id
  }
  sym_id := insert_symbol(sym_map)

  params_node := node_child(fdecl_node, "parameters")
  if params_node != nil {
    extract_cpp_params(sym_id, params_node)
  }

  if ret_type != "" && ret_type != "void" {
    insert_function_param({
      symbol_id: sym_id,
      name: "",
      ordinal: 0,
      type_expr: ret_type,
      is_receiver: false,
      is_return: true,
    })
  }
}

// --- Template function definitions ---
tmpl_func_matches := query("(template_declaration (function_definition declarator: (function_declarator) @fdecl) @func) @tmpl", root)
for _, m := range tmpl_func_matches {
  func_node := m["func"]
  fdecl_node := m["fdecl"]
  tmpl_node := m["tmpl"]

  name_node := node_child(fdecl_node, "declarator")
  if name_node == nil {
    continue
  }
  name := extract_declarator_name(name_node)

  type_node := node_child(func_node, "type")
  ret_type := ""
  if type_node != nil {
    ret_type = node_text(type_node)
  }

  sym_id := insert_symbol({
    file_id: file_id,
    name: name,
    kind: "function",
    visibility: "public",
    start_line: start_line(tmpl_node),
    start_col: start_col(tmpl_node),
    end_line: end_line(tmpl_node),
    end_col: end_col(tmpl_node),
  })

  params_node := node_child(fdecl_node, "parameters")
  if params_node != nil {
    extract_cpp_params(sym_id, params_node)
  }

  if ret_type != "" && ret_type != "void" {
    insert_function_param({
      symbol_id: sym_id,
      name: "",
      ordinal: 0,
      type_expr: ret_type,
      is_receiver: false,
      is_return: true,
    })
  }

  // Extract template type params
  tp_matches := query("(template_parameter_list (type_parameter_declaration (type_identifier) @tp_name))", tmpl_node)
  ordinal := 0
  for _, tp := range tp_matches {
    tp_name := node_text(tp["tp_name"])
    insert_type_param({
      symbol_id: sym_id,
      name: tp_name,
      ordinal: ordinal,
      param_kind: "type",
      constraints: "",
    })
    ordinal = ordinal + 1
  }
}

// --- Function declarations (prototypes, not definitions) ---
proto_matches := query("(declaration type: (_) @type declarator: (function_declarator) @fdecl) @decl", root)
for _, m := range proto_matches {
  decl_node := m["decl"]
  fdecl_node := m["fdecl"]

  // Skip if inside class/struct body
  parent := decl_node.Parent()
  if parent != nil {
    pt := parent.Type()
    if pt == "field_declaration_list" {
      continue
    }
  }

  name_node := node_child(fdecl_node, "declarator")
  if name_node == nil {
    continue
  }
  name := extract_declarator_name(name_node)

  // Skip if already exists
  existing := find_symbol_id(name)
  if existing != nil {
    continue
  }

  type_node := m["type"]
  ret_type := node_text(type_node)

  sym_id := insert_symbol({
    file_id: file_id,
    name: name,
    kind: "function",
    visibility: "public",
    start_line: start_line(decl_node),
    start_col: start_col(decl_node),
    end_line: end_line(decl_node),
    end_col: end_col(decl_node),
  })

  params_node := node_child(fdecl_node, "parameters")
  if params_node != nil {
    extract_cpp_params(sym_id, params_node)
  }

  if ret_type != "" && ret_type != "void" {
    insert_function_param({
      symbol_id: sym_id,
      name: "",
      ordinal: 0,
      type_expr: ret_type,
      is_receiver: false,
      is_return: true,
    })
  }
}

// --- Global variable declarations ---
global_decl_matches := query("(declaration type: (_) @type declarator: (init_declarator declarator: (identifier) @name)) @decl", root)
for _, m := range global_decl_matches {
  name_node := m["name"]
  decl_node := m["decl"]
  // Skip if inside a class/struct body
  parent := decl_node.Parent()
  if parent != nil && parent.Type() == "field_declaration_list" {
    continue
  }
  existing := find_symbol_id(node_text(name_node))
  if existing != nil {
    continue
  }
  insert_symbol({
    file_id: file_id,
    name: node_text(name_node),
    kind: "variable",
    visibility: "public",
    start_line: start_line(decl_node),
    start_col: start_col(decl_node),
    end_line: end_line(decl_node),
    end_col: end_col(decl_node),
  })
}

// --- Scope tree ---
file_scope_id := insert_scope({
  file_id: file_id,
  kind: "file",
  start_line: start_line(root),
  start_col: start_col(root),
  end_line: end_line(root),
  end_col: end_col(root),
})

// Namespace scopes
ns_scope_matches := query("(namespace_definition) @ns", root)
for _, m := range ns_scope_matches {
  ns_node := m["ns"]
  ns_nn := node_child(ns_node, "name")
  ns_sym_id := nil
  if ns_nn != nil {
    ns_sym_id = find_symbol_id(node_text(ns_nn))
  }
  scope_map := {
    file_id: file_id,
    kind: "namespace",
    start_line: start_line(ns_node),
    start_col: start_col(ns_node),
    end_line: end_line(ns_node),
    end_col: end_col(ns_node),
    parent_scope_id: file_scope_id,
  }
  if ns_sym_id != nil {
    scope_map["symbol_id"] = ns_sym_id
  }
  insert_scope(scope_map)
}

// Class scopes
class_scope_matches := query("(class_specifier name: (type_identifier) @name body: (field_declaration_list) @body) @cls", root)
for _, m := range class_scope_matches {
  cls_node := m["cls"]
  cls_nn := m["name"]
  cls_sym_id := nil
  if cls_nn != nil {
    cls_sym_id = find_symbol_id(node_text(cls_nn))
  }
  scope_map := {
    file_id: file_id,
    kind: "class",
    start_line: start_line(cls_node),
    start_col: start_col(cls_node),
    end_line: end_line(cls_node),
    end_col: end_col(cls_node),
    parent_scope_id: file_scope_id,
  }
  if cls_sym_id != nil {
    scope_map["symbol_id"] = cls_sym_id
  }
  insert_scope(scope_map)
}

// Function scopes (top-level)
fn_scope_matches := query("(function_definition) @fn", root)
for _, m := range fn_scope_matches {
  fn_node := m["fn"]

  // Skip if inside class body
  parent := fn_node.Parent()
  if parent != nil && parent.Type() == "field_declaration_list" {
    continue
  }
  // Skip template-wrapped (handled separately)
  if parent != nil && parent.Type() == "template_declaration" {
    continue
  }

  fdecl := node_child(fn_node, "declarator")
  fn_sym_id := nil
  if fdecl != nil {
    nn := node_child(fdecl, "declarator")
    if nn != nil {
      fn_sym_id = find_symbol_id(extract_declarator_name(nn))
    }
  }
  scope_map := {
    file_id: file_id,
    kind: "function",
    start_line: start_line(fn_node),
    start_col: start_col(fn_node),
    end_line: end_line(fn_node),
    end_col: end_col(fn_node),
    parent_scope_id: file_scope_id,
  }
  if fn_sym_id != nil {
    scope_map["symbol_id"] = fn_sym_id
  }
  fn_scope_id := insert_scope(scope_map)
  body_node := node_child(fn_node, "body")
  if body_node != nil {
    extract_block_scopes(body_node, fn_scope_id)
  }
}

// Template function scopes
tmpl_fn_scope_matches := query("(template_declaration (function_definition) @fn) @tmpl", root)
for _, m := range tmpl_fn_scope_matches {
  fn_node := m["fn"]
  tmpl_node := m["tmpl"]

  fdecl := node_child(fn_node, "declarator")
  fn_sym_id := nil
  if fdecl != nil {
    nn := node_child(fdecl, "declarator")
    if nn != nil {
      fn_sym_id = find_symbol_id(extract_declarator_name(nn))
    }
  }
  scope_map := {
    file_id: file_id,
    kind: "function",
    start_line: start_line(tmpl_node),
    start_col: start_col(tmpl_node),
    end_line: end_line(tmpl_node),
    end_col: end_col(tmpl_node),
    parent_scope_id: file_scope_id,
  }
  if fn_sym_id != nil {
    scope_map["symbol_id"] = fn_sym_id
  }
  fn_scope_id := insert_scope(scope_map)
  body_node := node_child(fn_node, "body")
  if body_node != nil {
    extract_block_scopes(body_node, fn_scope_id)
  }
}

// --- References ---

// Simple function calls
call_matches := query("(call_expression function: (identifier) @name) @call", root)
for _, m := range call_matches {
  name_node := m["name"]
  insert_reference({
    file_id: file_id,
    name: node_text(name_node),
    context: "call",
    start_line: start_line(name_node),
    start_col: start_col(name_node),
    end_line: end_line(name_node),
    end_col: end_col(name_node),
  })
}

// Qualified calls: std::sort(), obj.method(), ptr->method()
field_call_matches := query("(call_expression function: (field_expression argument: (_) @obj field: (field_identifier) @field))", root)
for _, m := range field_call_matches {
  field_node := m["field"]
  insert_reference({
    file_id: file_id,
    name: node_text(field_node),
    context: "call",
    start_line: start_line(field_node),
    start_col: start_col(field_node),
    end_line: end_line(field_node),
    end_col: end_col(field_node),
  })
}

// Non-call field access
field_matches := query("(field_expression argument: (_) @obj field: (field_identifier) @field) @fexpr", root)
for _, m := range field_matches {
  fexpr_node := m["fexpr"]
  parent := fexpr_node.Parent()
  if parent != nil && parent.Type() == "call_expression" {
    // Already handled above
  } else {
    field_node := m["field"]
    insert_reference({
      file_id: file_id,
      name: node_text(field_node),
      context: "field_access",
      start_line: start_line(field_node),
      start_col: start_col(field_node),
      end_line: end_line(field_node),
      end_col: end_col(field_node),
    })
  }
}

// Type references
type_ref_matches := query("(type_identifier) @type_id", root)
for _, m := range type_ref_matches {
  tn := m["type_id"]
  type_name := node_text(tn)

  parent := tn.Parent()
  is_decl := false
  if parent != nil {
    pt := parent.Type()
    if pt == "class_specifier" || pt == "struct_specifier" || pt == "enum_specifier" {
      p_name := node_child(parent, "name")
      if p_name != nil && node_text(p_name) == type_name {
        is_decl = true
      }
    }
    if pt == "type_definition" {
      p_decl := node_child(parent, "declarator")
      if p_decl != nil && node_text(p_decl) == type_name {
        is_decl = true
      }
    }
    // Template type parameter declaration
    if pt == "type_parameter_declaration" {
      is_decl = true
    }
  }

  if !is_decl {
    insert_reference({
      file_id: file_id,
      name: type_name,
      context: "type_annotation",
      start_line: start_line(tn),
      start_col: start_col(tn),
      end_line: end_line(tn),
      end_col: end_col(tn),
    })
  }
}
