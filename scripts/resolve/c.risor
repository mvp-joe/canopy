// C language resolution script for Canopy.
//
// This script works entirely with relational data in SQLite — NO tree-sitter access.
// It receives these globals:
//   files_by_language, symbols_by_file, symbols_by_name, symbols_by_kind
//   references_by_file, scopes_by_file, imports_by_file
//   type_members, function_params, scope_chain, batch_scope_chains
//   insert_resolved_reference, insert_implementation,
//   insert_call_edge, insert_extension_binding
//   db_query, log

import filepath
import strings
from "lib/resolve_helpers" import find_scope_for_ref, find_caller_symbol_id, create_call_edges

// ========== Helper functions (define-before-use) ==========

// basename extracts the filename from a path.
func basename(path) {
  return filepath.base(path)
}

// ========== Main resolution pipeline ==========

c_files := files_by_language("c")
if len(c_files) == 0 {
  // Nothing to resolve
}

// --- Build file-level data caches ---
file_symbols_map := {}
file_scopes_map := {}
file_imports_map := {}
// Map from file basename → list of file_ids (for include resolution)
file_basename_map := {}
file_refs_map := {}
file_scope_chains := {}
// name → [sym] index per file for O(1) lookup
file_sym_name_map := {}
// sym_id_str → sym index per file for O(1) lookup
file_sym_by_id := {}

for _, f := range c_files {
  fid := f["id"]
  fid_str := string(fid)

  syms := symbols_by_file(fid)
  file_symbols_map[fid_str] = syms
  file_scopes_map[fid_str] = scopes_by_file(fid)
  file_imports_map[fid_str] = imports_by_file(fid)
  file_refs_map[fid_str] = references_by_file(fid)
  file_scope_chains[fid_str] = batch_scope_chains(fid)

  // Index by basename for include resolution
  path := f["path"]
  bn := basename(path)
  existing := []
  if bn in file_basename_map {
    existing = file_basename_map[bn]
  }
  existing = existing.append(fid)
  file_basename_map[bn] = existing

  // Build name → [sym] index
  name_map := {}
  id_map := {}
  for _, sym := range syms {
    name := sym["name"]
    if !(name in name_map) { name_map[name] = [] }
    name_map[name] = name_map[name].append(sym)
    id_map[string(sym["id"])] = sym
  }
  file_sym_name_map[fid_str] = name_map
  file_sym_by_id[fid_str] = id_map
}

// Track which references have been resolved (ref_id_str → true)
resolved_set := {}

resolve_files := files_to_resolve("c")
resolve_fid_set := {}
for _, f := range resolve_files {
  resolve_fid_set[string(f["id"])] = true
}

// --- (a) Single-file scope-based name resolution ---
for _, f := range resolve_files {
  fid := f["id"]
  fid_str := string(fid)
  refs := file_refs_map[fid_str]
  scope_chains := file_scope_chains[fid_str]
  sym_name_map := file_sym_name_map[fid_str]

  for _, ref := range refs {
    ref_id := ref["id"]
    ref_name := ref["name"]
    ref_scope_id := nil
    if "scope_id" in ref {
      ref_scope_id = ref["scope_id"]
    }

    if ref_scope_id != nil {
      chain := []
      sid_str := string(ref_scope_id)
      if sid_str in scope_chains {
        chain = scope_chains[sid_str]
      }

      // Get candidate symbols by name (O(1) instead of scanning all symbols)
      candidates := []
      if ref_name in sym_name_map {
        candidates = sym_name_map[ref_name]
      }

      found := false
      for _, sc := range chain {
        for _, sym := range candidates {
          sym_line := sym["start_line"]
          if sym_line >= sc["start_line"] && sym_line <= sc["end_line"] {
            insert_resolved_reference({
              reference_id: ref_id,
              target_symbol_id: sym["id"],
              confidence: 1.0,
              resolution_kind: "direct",
            })
            ref_id_str := string(ref_id)
            resolved_set[ref_id_str] = true
            found = true
            break
          }
        }
        if found {
          break
        }
      }
    } else {
      // No scope_id — try file-level matching via name index
      candidates := []
      if ref_name in sym_name_map {
        candidates = sym_name_map[ref_name]
      }
      for _, sym := range candidates {
        insert_resolved_reference({
          reference_id: ref_id,
          target_symbol_id: sym["id"],
          confidence: 0.9,
          resolution_kind: "direct",
        })
        ref_id_str := string(ref_id)
        resolved_set[ref_id_str] = true
        break
      }
    }
  }
}

// --- (b) Include-based cross-file resolution ---
// For unresolved references, check if the file includes headers that
// match basenames of other C files in the store. Resolve against symbols
// in those included files.
for _, f := range resolve_files {
  fid := f["id"]
  fid_str := string(fid)
  refs := file_refs_map[fid_str]
  imports := file_imports_map[fid_str]

  // Collect file_ids of files included by this file
  included_file_ids := []
  for _, imp := range imports {
    if imp["kind"] != "header" {
      continue
    }
    source := imp["source"]
    inc_basename := basename(source)
    if inc_basename in file_basename_map {
      for _, inc_fid := range file_basename_map[inc_basename] {
        if inc_fid != fid {
          included_file_ids = included_file_ids.append(inc_fid)
        }
      }
    }
  }

  if len(included_file_ids) == 0 {
    continue
  }

  for _, ref := range refs {
    ref_id := ref["id"]
    ref_id_str := string(ref_id)
    if ref_id_str in resolved_set {
      continue
    }
    ref_name := ref["name"]

    found := false
    for _, inc_fid := range included_file_ids {
      inc_fid_str := string(inc_fid)
      inc_syms := file_symbols_map[inc_fid_str]
      for _, sym := range inc_syms {
        if sym["name"] == ref_name {
          insert_resolved_reference({
            reference_id: ref_id,
            target_symbol_id: sym["id"],
            confidence: 1.0,
            resolution_kind: "import",
          })
          resolved_set[ref_id_str] = true
          found = true
          break
        }
      }
      if found {
        break
      }
    }
  }
}

// --- (c) Struct field access resolution ---
// For field_access references, try matching against struct fields (type_members).
for _, f := range resolve_files {
  fid := f["id"]
  fid_str := string(fid)
  refs := file_refs_map[fid_str]

  for _, ref := range refs {
    ref_id := ref["id"]
    ref_id_str := string(ref_id)
    if ref_id_str in resolved_set {
      continue
    }
    ref_ctx := ref["context"]
    ref_name := ref["name"]

    if ref_ctx == "field_access" {
      // Search all structs in all C files for a matching field
      for _, other_f := range c_files {
        other_fid := other_f["id"]
        other_fid_str := string(other_fid)
        other_syms := file_symbols_map[other_fid_str]
        for _, sym := range other_syms {
          if sym["kind"] == "struct" {
            members := type_members(sym["id"])
            for _, mem := range members {
              if mem["name"] == ref_name {
                insert_resolved_reference({
                  reference_id: ref_id,
                  target_symbol_id: sym["id"],
                  confidence: 0.7,
                  resolution_kind: "direct",
                })
                resolved_set[ref_id_str] = true
                break
              }
            }
            if ref_id_str in resolved_set {
              break
            }
          }
        }
        if ref_id_str in resolved_set {
          break
        }
      }
    }
  }
}

// --- (d) Cross-file resolution (fallback for remaining unresolved) ---
// For references still unresolved, try matching against symbols in all C files.
for _, f := range resolve_files {
  fid := f["id"]
  fid_str := string(fid)
  refs := file_refs_map[fid_str]

  for _, ref := range refs {
    ref_id := ref["id"]
    ref_id_str := string(ref_id)
    if ref_id_str in resolved_set {
      continue
    }
    ref_name := ref["name"]

    for _, other_f := range c_files {
      other_fid := other_f["id"]
      if other_fid == fid {
        continue
      }
      other_fid_str := string(other_fid)
      other_syms := file_symbols_map[other_fid_str]
      for _, sym := range other_syms {
        if sym["name"] == ref_name {
          insert_resolved_reference({
            reference_id: ref_id,
            target_symbol_id: sym["id"],
            confidence: 0.8,
            resolution_kind: "direct",
          })
          resolved_set[ref_id_str] = true
          break
        }
      }
      if ref_id_str in resolved_set {
        break
      }
    }
  }
}

// --- (e) Call graph edge creation ---
for _, f := range resolve_files {
  fid := f["id"]
  fid_str := string(fid)
  refs := file_refs_map[fid_str]
  scopes := file_scopes_map[fid_str]
  create_call_edges(refs, resolved_set, scopes, fid, file_scope_chains[fid_str], file_sym_by_id[fid_str], nil)
}
