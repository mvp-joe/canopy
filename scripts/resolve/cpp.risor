// C++ language resolution script for Canopy.
//
// Extends C resolution with namespace, class hierarchy, virtual methods,
// and template awareness.
//
// This script works entirely with relational data in SQLite — NO tree-sitter access.
// It receives these globals:
//   files_by_language, symbols_by_file, symbols_by_name, symbols_by_kind
//   references_by_file, scopes_by_file, imports_by_file
//   type_members, function_params, scope_chain
//   insert_resolved_reference, insert_implementation,
//   insert_call_edge, insert_extension_binding
//   db_query, log

import strings

// ========== Helper functions (define-before-use) ==========

// find_scope_for_ref returns the innermost scope that contains the given reference.
func find_scope_for_ref(scopes, ref) {
  ref_line := ref["start_line"]
  ref_col := ref["start_col"]
  best := nil
  best_size := -1
  for _, sc := range scopes {
    sl := sc["start_line"]
    sc_col := sc["start_col"]
    el := sc["end_line"]
    ec := sc["end_col"]
    inside := false
    if ref_line > sl && ref_line < el {
      inside = true
    } else if ref_line == sl && ref_line == el {
      inside = ref_col >= sc_col && ref_col <= ec
    } else if ref_line == sl {
      inside = ref_col >= sc_col
    } else if ref_line == el {
      inside = ref_col <= ec
    }
    if inside {
      size := (el - sl) * 10000 + (ec - sc_col)
      if best == nil || size < best_size {
        best = sc
        best_size = size
      }
    }
  }
  return best
}

// find_caller_symbol_id walks the scope chain from a reference's scope upward
// to find the enclosing function/method scope and returns its symbol_id.
func find_caller_symbol_id(ref_scope_id) {
  if ref_scope_id == nil {
    return nil
  }
  chain := scope_chain(ref_scope_id)
  for _, sc := range chain {
    if sc["kind"] == "function" {
      sym_id := nil
      if "symbol_id" in sc {
        sym_id = sc["symbol_id"]
      }
      if sym_id != nil {
        sym_rows := db_query(
          "SELECT kind FROM symbols WHERE id = ?",
          sym_id,
        )
        if len(sym_rows) > 0 {
          sym_kind := sym_rows[0]["kind"]
          if sym_kind == "function" || sym_kind == "method" {
            return sym_id
          }
        }
        scope_syms := db_query(
          "SELECT id FROM symbols WHERE file_id = (SELECT file_id FROM scopes WHERE id = ?) AND (kind = 'function' OR kind = 'method') AND start_line = ? AND start_col = ?",
          sc["id"], sc["start_line"], sc["start_col"],
        )
        if len(scope_syms) > 0 {
          return scope_syms[0]["id"]
        }
      }
    }
  }
  return nil
}

// basename extracts the filename from a path.
func basename(path) {
  parts := strings.split(path, "/")
  result := parts[len(parts) - 1]
  parts2 := strings.split(result, "\\")
  return parts2[len(parts2) - 1]
}

// ========== Main resolution pipeline ==========

cpp_files := files_by_language("cpp")
if len(cpp_files) == 0 {
  // Nothing to resolve
}

// --- Build file-level data caches ---
file_symbols_map := {}
file_scopes_map := {}
file_imports_map := {}
file_basename_map := {}

for _, f := range cpp_files {
  fid := f["id"]
  fid_str := string(fid)

  file_symbols_map[fid_str] = symbols_by_file(fid)
  file_scopes_map[fid_str] = scopes_by_file(fid)
  file_imports_map[fid_str] = imports_by_file(fid)

  path := f["path"]
  bn := basename(path)
  existing := []
  if bn in file_basename_map {
    existing = file_basename_map[bn]
  }
  existing = existing.append(fid)
  file_basename_map[bn] = existing
}

// Track resolved references
resolved_set := {}

// --- (a) Single-file scope-based name resolution ---
for _, f := range cpp_files {
  fid := f["id"]
  fid_str := string(fid)
  refs := references_by_file(fid)
  file_syms := file_symbols_map[fid_str]

  for _, ref := range refs {
    ref_id := ref["id"]
    ref_name := ref["name"]
    ref_scope_id := nil
    if "scope_id" in ref {
      ref_scope_id = ref["scope_id"]
    }

    if ref_scope_id != nil {
      chain := scope_chain(ref_scope_id)
      found := false
      for _, sc := range chain {
        for _, sym := range file_syms {
          if sym["name"] != ref_name {
            continue
          }
          sym_line := sym["start_line"]
          if sym_line >= sc["start_line"] && sym_line <= sc["end_line"] {
            insert_resolved_reference({
              reference_id: ref_id,
              target_symbol_id: sym["id"],
              confidence: 1.0,
              resolution_kind: "direct",
            })
            ref_id_str := string(ref_id)
            resolved_set[ref_id_str] = true
            found = true
            break
          }
        }
        if found {
          break
        }
      }
    } else {
      for _, sym := range file_syms {
        if sym["name"] == ref_name {
          insert_resolved_reference({
            reference_id: ref_id,
            target_symbol_id: sym["id"],
            confidence: 0.9,
            resolution_kind: "direct",
          })
          ref_id_str := string(ref_id)
          resolved_set[ref_id_str] = true
          break
        }
      }
    }
  }
}

// --- (b) Include-based cross-file resolution ---
for _, f := range cpp_files {
  fid := f["id"]
  fid_str := string(fid)
  refs := references_by_file(fid)
  imports := file_imports_map[fid_str]

  included_file_ids := []
  for _, imp := range imports {
    if imp["kind"] != "header" {
      continue
    }
    source := imp["source"]
    inc_basename := basename(source)
    if inc_basename in file_basename_map {
      for _, inc_fid := range file_basename_map[inc_basename] {
        if inc_fid != fid {
          included_file_ids = included_file_ids.append(inc_fid)
        }
      }
    }
  }

  if len(included_file_ids) == 0 {
    continue
  }

  for _, ref := range refs {
    ref_id := ref["id"]
    ref_id_str := string(ref_id)
    if ref_id_str in resolved_set {
      continue
    }
    ref_name := ref["name"]

    found := false
    for _, inc_fid := range included_file_ids {
      inc_fid_str := string(inc_fid)
      inc_syms := file_symbols_map[inc_fid_str]
      for _, sym := range inc_syms {
        if sym["name"] == ref_name {
          insert_resolved_reference({
            reference_id: ref_id,
            target_symbol_id: sym["id"],
            confidence: 1.0,
            resolution_kind: "import",
          })
          resolved_set[ref_id_str] = true
          found = true
          break
        }
      }
      if found {
        break
      }
    }
  }
}

// --- (c) Namespace-qualified name resolution ---
// For references matching an imported symbol (via "using" declarations),
// resolve against symbols with that name across all files.
for _, f := range cpp_files {
  fid := f["id"]
  fid_str := string(fid)
  refs := references_by_file(fid)
  imports := file_imports_map[fid_str]

  // Build import name map for this file
  import_name_map := {}
  for _, imp := range imports {
    kind := imp["kind"]
    if kind == "symbol" {
      // using std::string — imported_name is "string"
      imported_name := ""
      if "imported_name" in imp {
        imported_name = imp["imported_name"]
      }
      if imported_name != "" {
        import_name_map[imported_name] = imp
      }
    }
  }

  for _, ref := range refs {
    ref_id := ref["id"]
    ref_id_str := string(ref_id)
    if ref_id_str in resolved_set {
      continue
    }
    ref_name := ref["name"]

    // Check if this reference matches a using-imported symbol
    if ref_name in import_name_map {
      target_syms := symbols_by_name(ref_name)
      for _, sym := range target_syms {
        sym_file_id := nil
        if "file_id" in sym {
          sym_file_id = sym["file_id"]
        }
        if sym_file_id == fid {
          continue
        }
        insert_resolved_reference({
          reference_id: ref_id,
          target_symbol_id: sym["id"],
          confidence: 0.9,
          resolution_kind: "import",
        })
        resolved_set[ref_id_str] = true
        break
      }
    }
  }
}

// --- (d) Method and field access resolution ---
// For call/field_access references, try to match against class/struct methods and fields.
for _, f := range cpp_files {
  fid := f["id"]
  fid_str := string(fid)
  refs := references_by_file(fid)

  for _, ref := range refs {
    ref_id := ref["id"]
    ref_id_str := string(ref_id)
    if ref_id_str in resolved_set {
      continue
    }
    ref_ctx := ref["context"]
    ref_name := ref["name"]

    if ref_ctx == "call" || ref_ctx == "field_access" {
      // Look for methods with this name across all files
      for _, other_f := range cpp_files {
        other_fid := other_f["id"]
        other_fid_str := string(other_fid)
        other_syms := file_symbols_map[other_fid_str]
        for _, sym := range other_syms {
          if sym["name"] == ref_name && sym["kind"] == "method" {
            insert_resolved_reference({
              reference_id: ref_id,
              target_symbol_id: sym["id"],
              confidence: 0.8,
              resolution_kind: "direct",
            })
            resolved_set[ref_id_str] = true
            break
          }
        }
        if ref_id_str in resolved_set {
          break
        }
      }

      // Also check class/struct fields and type_members for field_access
      if !(ref_id_str in resolved_set) {
        for _, other_f := range cpp_files {
          other_fid := other_f["id"]
          other_fid_str := string(other_fid)
          other_syms := file_symbols_map[other_fid_str]
          for _, sym := range other_syms {
            if sym["kind"] == "struct" || sym["kind"] == "class" {
              members := type_members(sym["id"])
              for _, mem := range members {
                if mem["name"] == ref_name && mem["kind"] != "embedded" {
                  insert_resolved_reference({
                    reference_id: ref_id,
                    target_symbol_id: sym["id"],
                    confidence: 0.7,
                    resolution_kind: "direct",
                  })
                  resolved_set[ref_id_str] = true
                  break
                }
              }
              if ref_id_str in resolved_set {
                break
              }
            }
          }
          if ref_id_str in resolved_set {
            break
          }
        }
      }
    }
  }
}

// --- (e) Cross-file resolution (fallback for remaining unresolved) ---
for _, f := range cpp_files {
  fid := f["id"]
  fid_str := string(fid)
  refs := references_by_file(fid)

  for _, ref := range refs {
    ref_id := ref["id"]
    ref_id_str := string(ref_id)
    if ref_id_str in resolved_set {
      continue
    }
    ref_name := ref["name"]

    for _, other_f := range cpp_files {
      other_fid := other_f["id"]
      if other_fid == fid {
        continue
      }
      other_fid_str := string(other_fid)
      other_syms := file_symbols_map[other_fid_str]
      for _, sym := range other_syms {
        if sym["name"] == ref_name {
          insert_resolved_reference({
            reference_id: ref_id,
            target_symbol_id: sym["id"],
            confidence: 0.8,
            resolution_kind: "direct",
          })
          resolved_set[ref_id_str] = true
          break
        }
      }
      if ref_id_str in resolved_set {
        break
      }
    }
  }
}

// --- (f) Class hierarchy — inheritance detection ---
// For each class with "embedded" type_members (base classes), create implementation records.
all_classes := symbols_by_kind("class")
for _, cls := range all_classes {
  cls_id := cls["id"]
  members := type_members(cls_id)

  for _, mem := range members {
    if mem["kind"] != "embedded" {
      continue
    }
    base_name := mem["name"]

    // Find the base class symbol
    base_syms := symbols_by_name(base_name)
    for _, base_sym := range base_syms {
      if base_sym["kind"] == "class" || base_sym["kind"] == "struct" {
        impl_file_id := nil
        if "file_id" in cls {
          impl_file_id = cls["file_id"]
        }
        impl_map := {
          type_symbol_id: cls_id,
          interface_symbol_id: base_sym["id"],
          kind: "explicit",
        }
        if impl_file_id != nil {
          impl_map["file_id"] = impl_file_id
        }
        insert_implementation(impl_map)
        break
      }
    }
  }
}

// --- (g) Virtual method resolution ---
// For each class that inherits from a base, check if the derived class
// has methods that override base class virtual methods. Insert extension
// bindings for virtual overrides.
for _, cls := range all_classes {
  cls_id := cls["id"]
  cls_members := type_members(cls_id)

  // Find base classes
  for _, mem := range cls_members {
    if mem["kind"] != "embedded" {
      continue
    }
    base_name := mem["name"]

    // Find the base class symbol
    base_syms := symbols_by_name(base_name)
    for _, base_sym := range base_syms {
      if base_sym["kind"] != "class" && base_sym["kind"] != "struct" {
        continue
      }
      base_id := base_sym["id"]
      base_members := type_members(base_id)

      // Find virtual methods in the base
      for _, bm := range base_members {
        if bm["kind"] != "method" {
          continue
        }
        type_expr := ""
        if "type_expr" in bm {
          type_expr = bm["type_expr"]
        }
        is_virtual := strings.contains(type_expr, "virtual")
        if !is_virtual {
          continue
        }

        // Check if derived class has a method with the same name
        for _, cm := range cls_members {
          if cm["kind"] == "method" && cm["name"] == bm["name"] {
            // This is a virtual override — create extension binding
            // Find the derived class method symbol
            derived_methods := db_query(
              "SELECT id FROM symbols WHERE parent_symbol_id = ? AND kind = 'method' AND name = ?",
              cls_id, cm["name"],
            )
            if len(derived_methods) > 0 {
              insert_extension_binding({
                member_symbol_id: derived_methods[0]["id"],
                extended_type_expr: base_name,
                extended_type_symbol_id: base_id,
                kind: "override",
              })
            }
            break
          }
        }
      }
      break
    }
  }
}

// --- (h) Call graph edge creation ---
for _, f := range cpp_files {
  fid := f["id"]
  fid_str := string(fid)
  refs := references_by_file(fid)
  scopes := file_scopes_map[fid_str]

  for _, ref := range refs {
    ref_id := ref["id"]
    ref_id_str := string(ref_id)
    ref_ctx := ref["context"]

    if ref_ctx != "call" {
      continue
    }
    if !(ref_id_str in resolved_set) {
      continue
    }

    rr_rows := db_query(
      "SELECT target_symbol_id FROM resolved_references WHERE reference_id = ?",
      ref_id,
    )
    if len(rr_rows) == 0 {
      continue
    }

    target_sym_id := rr_rows[0]["target_symbol_id"]

    ref_scope := find_scope_for_ref(scopes, ref)
    caller_sym_id := nil
    if ref_scope != nil {
      caller_sym_id = find_caller_symbol_id(ref_scope["id"])
    }

    if caller_sym_id != nil && target_sym_id != nil {
      insert_call_edge({
        caller_symbol_id: caller_sym_id,
        callee_symbol_id: target_sym_id,
        file_id: fid,
        line: ref["start_line"],
        col: ref["start_col"],
      })
    }
  }
}

// --- (i) Extension bindings for out-of-class method definitions ---
// In C++, methods defined outside the class (Class::method) are extension bindings.
all_methods := symbols_by_kind("method")
for _, meth := range all_methods {
  parent_id := nil
  if "parent_symbol_id" in meth {
    parent_id = meth["parent_symbol_id"]
  }
  if parent_id == nil {
    continue
  }

  parent_rows := db_query(
    "SELECT name FROM symbols WHERE id = ?",
    parent_id,
  )
  if len(parent_rows) == 0 {
    continue
  }
  type_name := parent_rows[0]["name"]

  insert_extension_binding({
    member_symbol_id: meth["id"],
    extended_type_expr: type_name,
    extended_type_symbol_id: parent_id,
    kind: "method",
  })
}
