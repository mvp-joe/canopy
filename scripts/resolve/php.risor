// PHP language resolution script for Canopy.
//
// This script works entirely with relational data in SQLite — NO tree-sitter access.
// It receives these globals:
//   files_by_language, symbols_by_file, symbols_by_name, symbols_by_kind
//   references_by_file, scopes_by_file, imports_by_file
//   type_members, function_params, scope_chain, batch_scope_chains
//   insert_resolved_reference, insert_implementation,
//   insert_call_edge, insert_extension_binding
//   db_query, log

import strings

from "lib/resolve_helpers" import find_scope_for_ref, find_caller_symbol_id, create_call_edges

// ========== Helper functions (define-before-use) ==========

// find_enclosing_class_id walks the scope chain to find the enclosing class scope
// and returns the class symbol_id.
func find_enclosing_class_id(scope_id) {
  if scope_id == nil {
    return nil
  }
  chain := scope_chain(scope_id)
  for _, sc := range chain {
    if sc["kind"] == "class" {
      if "symbol_id" in sc {
        return sc["symbol_id"]
      }
    }
  }
  return nil
}

// get_class_method_names returns a map of method_name -> symbol_id for all
// methods of a class.
func get_class_method_names(class_sym_id) {
  methods := db_query(
    "SELECT id, name FROM symbols WHERE parent_symbol_id = ? AND kind = 'method'",
    class_sym_id,
  )
  result := {}
  for _, m := range methods {
    result[m["name"]] = m["id"]
  }
  return result
}

// get_all_class_methods returns method names from a class and all its ancestors
// (via base_clause / extends) and included traits. Returns map name -> symbol_id.
func get_all_class_methods(class_sym_id, class_methods_cache) {
  cs_str := string(class_sym_id)
  if cs_str in class_methods_cache {
    return class_methods_cache[cs_str]
  }

  result := get_class_method_names(class_sym_id)

  // Walk parent class (extends) and traits (embedded type_members)
  members := type_members(class_sym_id)
  for _, mem := range members {
    if mem["kind"] == "embedded" {
      // Trait inclusion or interface — find the trait/class symbol
      trait_name := mem["name"]
      trait_syms := db_query(
        "SELECT id FROM symbols WHERE name = ? AND (kind = 'trait' OR kind = 'class')",
        trait_name,
      )
      for _, ts := range trait_syms {
        trait_methods := get_all_class_methods(ts["id"], class_methods_cache)
        for k, v := range trait_methods {
          if !(k in result) {
            result[k] = v
          }
        }
      }
    }
  }

  class_methods_cache[cs_str] = result
  return result
}

// ========== Main resolution pipeline ==========

php_files := files_by_language("php")
if len(php_files) == 0 {
  // Nothing to resolve
}

// --- Build file-level data caches ---
file_symbols_map := {}
file_scopes_map := {}
file_imports_map := {}
file_namespace_map := {}
file_refs_map := {}
file_scope_chains := {}
// name → [sym] index per file for O(1) lookup
file_sym_name_map := {}
// sym_id_str → sym index per file for O(1) lookup
file_sym_by_id := {}

for _, f := range php_files {
  fid := f["id"]
  fid_str := string(fid)
  syms := symbols_by_file(fid)
  file_symbols_map[fid_str] = syms
  file_scopes_map[fid_str] = scopes_by_file(fid)
  file_imports_map[fid_str] = imports_by_file(fid)
  file_refs_map[fid_str] = references_by_file(fid)
  file_scope_chains[fid_str] = batch_scope_chains(fid)

  // Find namespace for this file
  ns_name := ""
  for _, sym := range syms {
    if sym["kind"] == "namespace" {
      ns_name = sym["name"]
      break
    }
  }
  file_namespace_map[fid_str] = ns_name

  // Build name → [sym] index
  name_map := {}
  id_map := {}
  for _, sym := range syms {
    name := sym["name"]
    if !(name in name_map) { name_map[name] = [] }
    name_map[name] = name_map[name].append(sym)
    id_map[string(sym["id"])] = sym
  }
  file_sym_name_map[fid_str] = name_map
  file_sym_by_id[fid_str] = id_map
}

// --- Build map of function-local variable symbol IDs per file ---
file_local_sym_ids := {}
for _, f := range php_files {
  fid := f["id"]
  fid_str := string(fid)
  scopes := file_scopes_map[fid_str]
  syms := file_symbols_map[fid_str]

  func_scopes := []
  for _, sc := range scopes {
    if sc["kind"] == "function" {
      func_scopes = func_scopes.append(sc)
    }
  }

  local_ids := {}
  for _, sym := range syms {
    if sym["kind"] == "variable" {
      sym_line := sym["start_line"]
      for _, fsc := range func_scopes {
        if sym_line >= fsc["start_line"] && sym_line <= fsc["end_line"] {
          local_ids[string(sym["id"])] = true
          break
        }
      }
    }
  }
  file_local_sym_ids[fid_str] = local_ids
}

// --- Build import alias map per file ---
// use App\Models\User => alias "User" -> import record
file_import_alias_map := {}
for _, f := range php_files {
  fid := f["id"]
  fid_str := string(fid)
  imports := file_imports_map[fid_str]
  alias_map := {}
  for _, imp := range imports {
    alias := ""
    if "local_alias" in imp && imp["local_alias"] != nil && imp["local_alias"] != "" {
      alias = imp["local_alias"]
    } else if "imported_name" in imp && imp["imported_name"] != nil {
      alias = imp["imported_name"]
    }
    if alias != "" {
      alias_map[alias] = imp
    }
  }
  file_import_alias_map[fid_str] = alias_map
}

// Track resolved references
resolved_set := {}

resolve_files := files_to_resolve("php")
resolve_fid_set := {}
for _, f := range resolve_files {
  resolve_fid_set[string(f["id"])] = true
}

// --- (a) Single-file scope-based name resolution ---
for _, f := range resolve_files {
  fid := f["id"]
  fid_str := string(fid)
  refs := file_refs_map[fid_str]
  scope_chains := file_scope_chains[fid_str]
  sym_name_map := file_sym_name_map[fid_str]

  for _, ref := range refs {
    ref_id := ref["id"]
    ref_name := ref["name"]
    ref_scope_id := nil
    if "scope_id" in ref {
      ref_scope_id = ref["scope_id"]
    }

    if ref_scope_id != nil {
      chain := []
      sid_str := string(ref_scope_id)
      if sid_str in scope_chains {
        chain = scope_chains[sid_str]
      }

      // Get candidate symbols by name (O(1) instead of scanning all symbols)
      candidates := []
      if ref_name in sym_name_map {
        candidates = sym_name_map[ref_name]
      }

      found := false
      for _, sc := range chain {
        for _, sym := range candidates {
          if sym["kind"] == "namespace" {
            continue
          }
          sym_line := sym["start_line"]
          if sym_line >= sc["start_line"] && sym_line <= sc["end_line"] {
            insert_resolved_reference({
              reference_id: ref_id,
              target_symbol_id: sym["id"],
              confidence: 1.0,
              resolution_kind: "direct",
            })
            resolved_set[string(ref_id)] = true
            found = true
            break
          }
        }
        if found {
          break
        }
      }
    } else {
      // No scope_id — try file-level matching via name index
      candidates := []
      if ref_name in sym_name_map {
        candidates = sym_name_map[ref_name]
      }
      for _, sym := range candidates {
        if sym["kind"] != "namespace" {
          insert_resolved_reference({
            reference_id: ref_id,
            target_symbol_id: sym["id"],
            confidence: 0.9,
            resolution_kind: "direct",
          })
          resolved_set[string(ref_id)] = true
          break
        }
      }
    }
  }
}

// --- (b) Cross-file use/namespace resolution ---
// For unresolved references that match an import alias (use statement),
// find the target symbol in other PHP files.
for _, f := range resolve_files {
  fid := f["id"]
  fid_str := string(fid)
  refs := file_refs_map[fid_str]
  alias_map := file_import_alias_map[fid_str]

  for _, ref := range refs {
    ref_id := ref["id"]
    ref_id_str := string(ref_id)
    if ref_id_str in resolved_set {
      continue
    }
    ref_name := ref["name"]

    if ref_name in alias_map {
      imp := alias_map[ref_name]
      imported_name := imp["imported_name"]

      // Find symbols with matching name across all PHP files
      target_syms := db_query(
        "SELECT s.id, s.name, s.kind FROM symbols s JOIN files f ON s.file_id = f.id WHERE s.name = ? AND f.language = 'php' AND f.id != ? AND s.kind != 'namespace'",
        imported_name, fid,
      )
      for _, ts := range target_syms {
        insert_resolved_reference({
          reference_id: ref_id,
          target_symbol_id: ts["id"],
          confidence: 1.0,
          resolution_kind: "import",
        })
        resolved_set[ref_id_str] = true
        break
      }
    }
  }
}

// --- (c) Cross-file name-based resolution (same name, no import needed) ---
// For still-unresolved references, try matching by name across all PHP files.
// Skip function-local symbols from other files.
for _, f := range resolve_files {
  fid := f["id"]
  fid_str := string(fid)
  refs := file_refs_map[fid_str]

  for _, ref := range refs {
    ref_id := ref["id"]
    ref_id_str := string(ref_id)
    if ref_id_str in resolved_set {
      continue
    }
    ref_name := ref["name"]
    ref_ctx := ref["context"]

    // Only resolve type_annotation and call contexts cross-file
    if ref_ctx == "type_annotation" || ref_ctx == "call" {
      target_syms := db_query(
        "SELECT s.id, s.kind, s.file_id FROM symbols s JOIN files f ON s.file_id = f.id WHERE s.name = ? AND f.language = 'php' AND f.id != ? AND s.kind != 'namespace'",
        ref_name, fid,
      )
      for _, ts := range target_syms {
        // Skip function-local symbols from other files
        ts_fid_str := string(ts["file_id"])
        ts_sid_str := string(ts["id"])
        if ts_fid_str in file_local_sym_ids && ts_sid_str in file_local_sym_ids[ts_fid_str] {
          continue
        }
        insert_resolved_reference({
          reference_id: ref_id,
          target_symbol_id: ts["id"],
          confidence: 0.8,
          resolution_kind: "direct",
        })
        resolved_set[ref_id_str] = true
        break
      }
    }
  }
}

// --- (d) Method resolution ---
// For "call" references that are still unresolved, try to match against
// methods of classes in the codebase (handling $obj->method() pattern).
class_methods_cache := {}

for _, f := range resolve_files {
  fid := f["id"]
  fid_str := string(fid)
  refs := file_refs_map[fid_str]
  scopes := file_scopes_map[fid_str]
  file_syms := file_symbols_map[fid_str]

  for _, ref := range refs {
    ref_id := ref["id"]
    ref_id_str := string(ref_id)
    if ref_id_str in resolved_set {
      continue
    }
    ref_name := ref["name"]
    ref_ctx := ref["context"]

    if ref_ctx == "call" {
      // First try enclosing class (for $this->method() pattern)
      ref_scope := find_scope_for_ref(scopes, ref)
      enclosing_class_id := nil
      if ref_scope != nil {
        enclosing_class_id = find_enclosing_class_id(ref_scope["id"])
      }

      if enclosing_class_id != nil {
        all_methods := get_all_class_methods(enclosing_class_id, class_methods_cache)
        if ref_name in all_methods {
          target_id := all_methods[ref_name]
          insert_resolved_reference({
            reference_id: ref_id,
            target_symbol_id: target_id,
            confidence: 0.9,
            resolution_kind: "direct",
          })
          resolved_set[ref_id_str] = true
          continue
        }
      }

      // Fallback: check all classes in same file
      found := false
      for _, sym := range file_syms {
        if sym["kind"] == "class" || sym["kind"] == "trait" {
          all_methods := get_all_class_methods(sym["id"], class_methods_cache)
          if ref_name in all_methods {
            target_id := all_methods[ref_name]
            insert_resolved_reference({
              reference_id: ref_id,
              target_symbol_id: target_id,
              confidence: 0.8,
              resolution_kind: "direct",
            })
            resolved_set[ref_id_str] = true
            found = true
            break
          }
        }
      }
      if found {
        continue
      }

      // Broader fallback: check all classes across all files
      all_classes := symbols_by_kind("class")
      for _, cls := range all_classes {
        all_methods := get_all_class_methods(cls["id"], class_methods_cache)
        if ref_name in all_methods {
          target_id := all_methods[ref_name]
          insert_resolved_reference({
            reference_id: ref_id,
            target_symbol_id: target_id,
            confidence: 0.7,
            resolution_kind: "direct",
          })
          resolved_set[ref_id_str] = true
          break
        }
      }
    }
  }
}

// --- (e) Class hierarchy: extends and implements ---
// For each class, check for base_clause (extends) and interface_clause (implements).
// We detect these via type_annotation references to parent classes/interfaces
// that appear in the class declaration range.
all_classes := symbols_by_kind("class")
for _, cls := range all_classes {
  if "file_id" in cls && !(string(cls["file_id"]) in resolve_fid_set) { continue }
  cls_id := cls["id"]
  cls_file_id := nil
  if "file_id" in cls {
    cls_file_id = cls["file_id"]
  }
  if cls_file_id == nil {
    continue
  }

  cls_fid_str := string(cls_file_id)
  refs := file_refs_map[cls_fid_str]

  // Find type_annotation references on the same line as the class declaration.
  // These are "extends Parent" and "implements Interface" references.
  cls_line := cls["start_line"]
  for _, ref := range refs {
    if ref["context"] != "type_annotation" {
      continue
    }
    if ref["start_line"] != cls_line {
      continue
    }
    ref_name := ref["name"]

    // Find the target symbol (class or interface)
    target_syms := db_query(
      "SELECT id, kind FROM symbols WHERE name = ? AND (kind = 'class' OR kind = 'interface' OR kind = 'trait') AND id != ?",
      ref_name, cls_id,
    )
    for _, ts := range target_syms {
      impl_kind := "explicit"
      impl_map := {
        type_symbol_id: cls_id,
        interface_symbol_id: ts["id"],
        kind: impl_kind,
      }
      if cls_file_id != nil {
        impl_map["file_id"] = cls_file_id
      }
      insert_implementation(impl_map)
    }
  }
}

// --- (f) Trait inclusion ---
// For each class/trait that has "embedded" type_members (trait use), create
// implementation records linking the class to the trait.
for _, cls := range all_classes {
  if "file_id" in cls && !(string(cls["file_id"]) in resolve_fid_set) { continue }
  cls_id := cls["id"]
  cls_file_id := nil
  if "file_id" in cls {
    cls_file_id = cls["file_id"]
  }

  members := type_members(cls_id)
  for _, mem := range members {
    if mem["kind"] == "embedded" {
      trait_name := mem["name"]
      trait_syms := db_query(
        "SELECT id FROM symbols WHERE name = ? AND kind = 'trait'",
        trait_name,
      )
      for _, ts := range trait_syms {
        impl_map := {
          type_symbol_id: cls_id,
          interface_symbol_id: ts["id"],
          kind: "trait",
        }
        if cls_file_id != nil {
          impl_map["file_id"] = cls_file_id
        }
        insert_implementation(impl_map)
      }
    }
  }
}

// --- (g) Call graph edge creation ---
for _, f := range resolve_files {
  fid := f["id"]
  fid_str := string(fid)
  refs := file_refs_map[fid_str]
  scopes := file_scopes_map[fid_str]
  create_call_edges(refs, resolved_set, scopes, fid, file_scope_chains[fid_str], file_sym_by_id[fid_str], {"function": true, "method": true, "static_method": true})
}
