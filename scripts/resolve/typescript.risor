// TypeScript language resolution script for Canopy.
//
// This script works entirely with relational data in SQLite — NO tree-sitter access.
// It receives these globals:
//   files_by_language, symbols_by_file, symbols_by_name, symbols_by_kind
//   references_by_file, scopes_by_file, imports_by_file
//   type_members, function_params, scope_chain, batch_scope_chains
//   insert_resolved_reference, insert_implementation,
//   insert_call_edge, insert_extension_binding
//   db_query, log

from "lib/resolve_helpers" import find_scope_for_ref, find_caller_symbol_id, create_call_edges
from "lib/path_helpers" import normalize_source, get_basename, strip_extension

// ========== Main resolution pipeline ==========

ts_files := files_by_language("typescript")
if len(ts_files) == 0 {
  // Nothing to resolve
}

// --- Build file-level data caches ---
file_symbols_map := {}
file_scopes_map := {}
file_imports_map := {}
file_refs_map := {}
file_scope_chains := {}
// name → [sym] index per file for O(1) lookup
file_sym_name_map := {}
// sym_id_str → sym index per file for O(1) lookup
file_sym_by_id := {}
// Map from file_id → file path
file_path_map := {}
// Map from normalized basename (no extension) → list of file_ids
module_files_map := {}

for _, f := range ts_files {
  fid := f["id"]
  fid_str := string(fid)

  syms := symbols_by_file(fid)
  file_symbols_map[fid_str] = syms

  file_scopes_map[fid_str] = scopes_by_file(fid)
  file_imports_map[fid_str] = imports_by_file(fid)
  file_refs_map[fid_str] = references_by_file(fid)
  file_scope_chains[fid_str] = batch_scope_chains(fid)

  // Build name → [sym] index
  name_map := {}
  id_map := {}
  for _, sym := range syms {
    name := sym["name"]
    if !(name in name_map) { name_map[name] = [] }
    name_map[name] = name_map[name].append(sym)
    id_map[string(sym["id"])] = sym
  }
  file_sym_name_map[fid_str] = name_map
  file_sym_by_id[fid_str] = id_map

  fpath := ""
  if "path" in f {
    fpath = f["path"]
  }
  file_path_map[fid_str] = fpath

  // Build module map from basename
  if fpath != "" {
    basename := get_basename(fpath)
    mod_name := strip_extension(basename)
    existing := []
    if mod_name in module_files_map {
      existing = module_files_map[mod_name]
    }
    existing = existing.append(fid)
    module_files_map[mod_name] = existing
  }
}

// --- Build import alias → source mapping per file ---
file_import_alias_map := {}
for _, f := range ts_files {
  fid := f["id"]
  fid_str := string(fid)
  imports := file_imports_map[fid_str]
  alias_map := {}
  for _, imp := range imports {
    alias := ""
    imp_kind := ""
    if "kind" in imp {
      imp_kind = imp["kind"]
    }
    if "local_alias" in imp && imp["local_alias"] != nil {
      alias = imp["local_alias"]
    }
    if alias == "" && "imported_name" in imp && imp["imported_name"] != nil {
      alias = imp["imported_name"]
    }
    if alias != "" && alias != "*" {
      alias_map[alias] = imp
    }
    // For namespace imports, the alias is the local_alias
    if imp_kind == "namespace" && "local_alias" in imp && imp["local_alias"] != nil {
      alias_map[imp["local_alias"]] = imp
    }
  }
  file_import_alias_map[fid_str] = alias_map
}

// Track which references have been resolved (ref_id → true)
resolved_set := {}

resolve_files := files_to_resolve("typescript")
resolve_fid_set := {}
for _, f := range resolve_files {
  resolve_fid_set[string(f["id"])] = true
}

// --- (a) Single-file scope-based name resolution ---
for _, f := range resolve_files {
  fid := f["id"]
  fid_str := string(fid)
  refs := file_refs_map[fid_str]
  scope_chains := file_scope_chains[fid_str]
  sym_name_map := file_sym_name_map[fid_str]

  for _, ref := range refs {
    ref_id := ref["id"]
    ref_name := ref["name"]
    ref_scope_id := nil
    if "scope_id" in ref {
      ref_scope_id = ref["scope_id"]
    }

    if ref_scope_id != nil {
      chain := []
      sid_str := string(ref_scope_id)
      if sid_str in scope_chains {
        chain = scope_chains[sid_str]
      }

      // Get candidate symbols by name (O(1) instead of scanning all symbols)
      candidates := []
      if ref_name in sym_name_map {
        candidates = sym_name_map[ref_name]
      }

      found := false
      for _, sc := range chain {
        for _, sym := range candidates {
          sym_line := sym["start_line"]
          if sym_line >= sc["start_line"] && sym_line <= sc["end_line"] {
            insert_resolved_reference({
              reference_id: ref_id,
              target_symbol_id: sym["id"],
              confidence: 1.0,
              resolution_kind: "direct",
            })
            ref_id_str := string(ref_id)
            resolved_set[ref_id_str] = true
            found = true
            break
          }
        }
        if found {
          break
        }
      }
    } else {
      // No scope_id — try file-level matching via name index
      candidates := []
      if ref_name in sym_name_map {
        candidates = sym_name_map[ref_name]
      }
      for _, sym := range candidates {
        insert_resolved_reference({
          reference_id: ref_id,
          target_symbol_id: sym["id"],
          confidence: 0.9,
          resolution_kind: "direct",
        })
        ref_id_str := string(ref_id)
        resolved_set[ref_id_str] = true
        break
      }
    }
  }
}

// --- (b) Cross-file import resolution ---
// For TS, imports map a local alias to a source module.
// We find files matching the source module and resolve named/default/namespace imports.
for _, f := range resolve_files {
  fid := f["id"]
  fid_str := string(fid)
  refs := file_refs_map[fid_str]
  alias_map := file_import_alias_map[fid_str]

  for _, ref := range refs {
    ref_id := ref["id"]
    ref_id_str := string(ref_id)
    if ref_id_str in resolved_set {
      continue
    }
    ref_name := ref["name"]
    ref_ctx := ""
    if "context" in ref {
      ref_ctx = ref["context"]
    }

    // Check if this reference name matches an import alias
    if ref_name in alias_map {
      imp := alias_map[ref_name]
      imp_source := imp["source"]
      imp_kind := ""
      if "kind" in imp {
        imp_kind = imp["kind"]
      }

      // Normalize the source to find matching files
      norm_source := normalize_source(imp_source)

      // For named imports, the imported name is the symbol to find in the source file
      imported_name := ref_name
      if "imported_name" in imp && imp["imported_name"] != nil {
        imported_name = imp["imported_name"]
      }

      // Find files that match this module source
      target_file_ids := []
      // First try exact basename match
      source_basename := get_basename(norm_source)
      if source_basename in module_files_map {
        target_file_ids = module_files_map[source_basename]
      }
      // Also try the full normalized path as a module name
      if len(target_file_ids) == 0 && norm_source in module_files_map {
        target_file_ids = module_files_map[norm_source]
      }

      for _, target_fid := range target_file_ids {
        if target_fid == fid {
          continue
        }
        target_fid_str := string(target_fid)
        target_syms := file_symbols_map[target_fid_str]

        if imp_kind == "default" {
          // Default import: look for a "public" symbol (exported) in target file
          // In TS/JS, the default export could be any symbol. We look for exported symbols.
          for _, sym := range target_syms {
            if sym["visibility"] == "public" {
              insert_resolved_reference({
                reference_id: ref_id,
                target_symbol_id: sym["id"],
                confidence: 0.8,
                resolution_kind: "import",
              })
              resolved_set[ref_id_str] = true
              break
            }
          }
        } else if imp_kind == "namespace" {
          // Namespace import: mark the namespace ref as resolved (it's the module itself)
          // The actual symbol resolution happens in field_access below
          resolved_set[ref_id_str] = true
        } else {
          // Named import: find the symbol by its imported name in the target file
          for _, sym := range target_syms {
            if sym["name"] == imported_name {
              insert_resolved_reference({
                reference_id: ref_id,
                target_symbol_id: sym["id"],
                confidence: 1.0,
                resolution_kind: "import",
              })
              resolved_set[ref_id_str] = true
              break
            }
          }
        }
        if ref_id_str in resolved_set {
          break
        }
      }
    }

    // For field_access refs, check if there's an import-alias reference on the same line
    // This handles "ns.Symbol" patterns (namespace imports or module.member)
    if ref_ctx == "field_access" && !(ref_id_str in resolved_set) {
      ref_line := ref["start_line"]
      for _, other_ref := range refs {
        other_name := other_ref["name"]
        if other_name in alias_map && other_ref["start_line"] == ref_line {
          imp := alias_map[other_name]
          imp_source := imp["source"]
          norm_source := normalize_source(imp_source)
          source_basename := get_basename(norm_source)

          target_file_ids := []
          if source_basename in module_files_map {
            target_file_ids = module_files_map[source_basename]
          }
          if len(target_file_ids) == 0 && norm_source in module_files_map {
            target_file_ids = module_files_map[norm_source]
          }

          for _, target_fid := range target_file_ids {
            if target_fid == fid {
              continue
            }
            target_fid_str := string(target_fid)
            target_syms := file_symbols_map[target_fid_str]
            for _, sym := range target_syms {
              if sym["name"] == ref_name && sym["visibility"] == "public" {
                insert_resolved_reference({
                  reference_id: ref_id,
                  target_symbol_id: sym["id"],
                  confidence: 1.0,
                  resolution_kind: "import",
                })
                resolved_set[ref_id_str] = true
                break
              }
            }
            if ref_id_str in resolved_set {
              break
            }
          }
          break
        }
      }
    }
  }
}

// --- (c) Method/field resolution (class member access) ---
// For field_access references not yet resolved, try matching against methods/fields
// of classes and interfaces in the same project.
for _, f := range resolve_files {
  fid := f["id"]
  fid_str := string(fid)
  refs := file_refs_map[fid_str]

  for _, ref := range refs {
    ref_id := ref["id"]
    ref_id_str := string(ref_id)
    if ref_id_str in resolved_set {
      continue
    }
    ref_ctx := ""
    if "context" in ref {
      ref_ctx = ref["context"]
    }
    ref_name := ref["name"]

    if ref_ctx == "field_access" {
      // Look for methods with this name across all TS files
      found := false
      for _, other_f := range ts_files {
        other_fid := other_f["id"]
        other_fid_str := string(other_fid)
        other_syms := file_symbols_map[other_fid_str]
        for _, sym := range other_syms {
          if sym["name"] == ref_name && sym["kind"] == "method" {
            insert_resolved_reference({
              reference_id: ref_id,
              target_symbol_id: sym["id"],
              confidence: 0.8,
              resolution_kind: "direct",
            })
            resolved_set[ref_id_str] = true
            found = true
            break
          }
        }
        if found {
          break
        }
      }

      // Check type members (interface/class members that may not be separate symbols)
      if !found {
        for _, other_f := range ts_files {
          other_fid := other_f["id"]
          other_fid_str := string(other_fid)
          other_syms := file_symbols_map[other_fid_str]
          for _, sym := range other_syms {
            if sym["kind"] == "class" || sym["kind"] == "interface" {
              members := type_members(sym["id"])
              for _, mem := range members {
                if mem["name"] == ref_name {
                  insert_resolved_reference({
                    reference_id: ref_id,
                    target_symbol_id: sym["id"],
                    confidence: 0.7,
                    resolution_kind: "direct",
                  })
                  resolved_set[ref_id_str] = true
                  found = true
                  break
                }
              }
              if found {
                break
              }
            }
          }
          if found {
            break
          }
        }
      }
    }
  }
}

// --- (d) Interface implementation detection ---
// TypeScript uses explicit "implements" keyword. We detect this via:
// 1. The extraction script records the "implements" clause as type_annotation refs
// 2. We also do structural matching: check if a class has all methods of an interface

all_interfaces := symbols_by_kind("interface")
all_classes := symbols_by_kind("class")

for _, iface := range all_interfaces {
  iface_id := iface["id"]
  iface_file_id := nil
  if "file_id" in iface {
    iface_file_id = iface["file_id"]
  }
  // Only consider interfaces in TS files
  if iface_file_id == nil {
    continue
  }
  iface_fid_str := string(iface_file_id)
  if !(iface_fid_str in file_symbols_map) {
    continue
  }

  iface_methods := type_members(iface_id)
  iface_method_names := []
  for _, m := range iface_methods {
    if m["kind"] == "method" {
      iface_method_names = iface_method_names.append(m["name"])
    }
  }
  if len(iface_method_names) == 0 {
    continue
  }

  for _, cls := range all_classes {
    if "file_id" in cls && !(string(cls["file_id"]) in resolve_fid_set) { continue }
    cls_id := cls["id"]
    cls_file_id := nil
    if "file_id" in cls {
      cls_file_id = cls["file_id"]
    }
    if cls_file_id == nil {
      continue
    }
    cls_fid_str := string(cls_file_id)
    if !(cls_fid_str in file_symbols_map) {
      continue
    }

    // Get class methods (symbols with parent_symbol_id == cls_id)
    cls_methods := db_query(
      "SELECT name FROM symbols WHERE parent_symbol_id = ? AND kind = 'method'",
      cls_id,
    )
    cls_method_names := {}
    for _, m := range cls_methods {
      cls_method_names[m["name"]] = true
    }

    // Also check type_members
    cls_members := type_members(cls_id)
    for _, m := range cls_members {
      if m["kind"] == "method" {
        cls_method_names[m["name"]] = true
      }
    }

    // Check if class has all interface methods
    satisfies := true
    for _, method_name := range iface_method_names {
      if !(method_name in cls_method_names) {
        satisfies = false
        break
      }
    }

    if satisfies {
      impl_map := {
        type_symbol_id: cls_id,
        interface_symbol_id: iface_id,
        kind: "structural",
      }
      if cls_file_id != nil {
        impl_map["file_id"] = cls_file_id
      }
      insert_implementation(impl_map)
    }
  }
}

// --- (e) Call graph edge creation ---
for _, f := range resolve_files {
  fid := f["id"]
  fid_str := string(fid)
  refs := file_refs_map[fid_str]
  scopes := file_scopes_map[fid_str]
  create_call_edges(refs, resolved_set, scopes, fid, file_scope_chains[fid_str], file_sym_by_id[fid_str], nil)
}

// --- (f) Extension bindings for class methods ---
// In TS, methods defined inside a class are bound to the class type.
all_methods := symbols_by_kind("method")
for _, meth := range all_methods {
  // Only consider methods in TS files
  meth_file_id := nil
  if "file_id" in meth {
    meth_file_id = meth["file_id"]
  }
  if meth_file_id == nil {
    continue
  }
  meth_fid_str := string(meth_file_id)
  if !(meth_fid_str in file_symbols_map) {
    continue
  }
  if !(meth_fid_str in resolve_fid_set) { continue }

  parent_id := nil
  if "parent_symbol_id" in meth {
    parent_id = meth["parent_symbol_id"]
  }
  if parent_id == nil {
    continue
  }

  // Get the parent class/interface name
  parent_rows := db_query(
    "SELECT name, kind FROM symbols WHERE id = ?",
    parent_id,
  )
  if len(parent_rows) == 0 {
    continue
  }
  parent_name := parent_rows[0]["name"]
  parent_kind := parent_rows[0]["kind"]

  if parent_kind != "class" && parent_kind != "interface" {
    continue
  }

  insert_extension_binding({
    member_symbol_id: meth["id"],
    extended_type_expr: parent_name,
    extended_type_symbol_id: parent_id,
    kind: "method",
  })
}
