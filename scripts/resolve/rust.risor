// Rust language resolution script for Canopy.
//
// This script works entirely with relational data in SQLite — NO tree-sitter access.
// It receives these globals:
//   files_by_language, symbols_by_file, symbols_by_name, symbols_by_kind
//   references_by_file, scopes_by_file, imports_by_file
//   type_members, function_params, scope_chain, batch_scope_chains
//   insert_resolved_reference, insert_implementation,
//   insert_call_edge, insert_extension_binding
//   db_query, log

import strings

from "lib/resolve_helpers" import find_scope_for_ref, find_caller_symbol_id, create_call_edges

// ========== Main resolution pipeline ==========

rust_files := files_by_language("rust")
if len(rust_files) == 0 {
  // Nothing to resolve
}

// --- Build file-level data caches ---
file_symbols_map := {}
file_scopes_map := {}
file_imports_map := {}
file_refs_map := {}
file_scope_chains := {}
// name → [sym] index per file for O(1) lookup
file_sym_name_map := {}
// sym_id_str → sym index per file for O(1) lookup
file_sym_by_id := {}

for _, f := range rust_files {
  fid := f["id"]
  fid_str := string(fid)

  syms := symbols_by_file(fid)
  file_symbols_map[fid_str] = syms
  file_scopes_map[fid_str] = scopes_by_file(fid)
  file_imports_map[fid_str] = imports_by_file(fid)
  file_refs_map[fid_str] = references_by_file(fid)
  file_scope_chains[fid_str] = batch_scope_chains(fid)

  // Build name → [sym] index
  name_map := {}
  id_map := {}
  for _, sym := range syms {
    name := sym["name"]
    if !(name in name_map) { name_map[name] = [] }
    name_map[name] = name_map[name].append(sym)
    id_map[string(sym["id"])] = sym
  }
  file_sym_name_map[fid_str] = name_map
  file_sym_by_id[fid_str] = id_map
}

// --- Build map of function-local variable symbol IDs per file ---
file_local_sym_ids := {}
for _, f := range rust_files {
  fid := f["id"]
  fid_str := string(fid)
  scopes := file_scopes_map[fid_str]
  syms := file_symbols_map[fid_str]

  func_scopes := []
  for _, sc := range scopes {
    if sc["kind"] == "function" {
      func_scopes = func_scopes.append(sc)
    }
  }

  local_ids := {}
  for _, sym := range syms {
    if sym["kind"] == "variable" || sym["kind"] == "constant" {
      sym_line := sym["start_line"]
      for _, fsc := range func_scopes {
        if sym_line >= fsc["start_line"] && sym_line <= fsc["end_line"] {
          local_ids[string(sym["id"])] = true
          break
        }
      }
    }
  }
  file_local_sym_ids[fid_str] = local_ids
}

// --- Build import name → import_map per file ---
// In Rust, `use std::collections::HashMap` makes "HashMap" available.
// The imported_name is the last segment of the use path.
file_import_name_map := {}
for _, f := range rust_files {
  fid := f["id"]
  fid_str := string(fid)
  imports := file_imports_map[fid_str]
  name_map := {}
  for _, imp := range imports {
    imported_name := ""
    if "imported_name" in imp {
      imported_name = imp["imported_name"]
    }
    // Check for local_alias (use X as Y)
    alias := ""
    if "local_alias" in imp {
      alias = imp["local_alias"]
    }
    effective_name := imported_name
    if alias != "" && alias != "_" {
      effective_name = alias
    }
    if effective_name != "" && effective_name != "*" && effective_name != "_" {
      name_map[effective_name] = imp
    }
  }
  file_import_name_map[fid_str] = name_map
}

// Track which references have been resolved
resolved_set := {}

resolve_files := files_to_resolve("rust")
resolve_fid_set := {}
for _, f := range resolve_files {
  resolve_fid_set[string(f["id"])] = true
}

// --- (a) Single-file scope-based name resolution ---
for _, f := range resolve_files {
  fid := f["id"]
  fid_str := string(fid)
  refs := file_refs_map[fid_str]
  scope_chains := file_scope_chains[fid_str]
  sym_name_map := file_sym_name_map[fid_str]

  for _, ref := range refs {
    ref_id := ref["id"]
    ref_name := ref["name"]
    ref_scope_id := nil
    if "scope_id" in ref {
      ref_scope_id = ref["scope_id"]
    }

    if ref_scope_id != nil {
      chain := []
      sid_str := string(ref_scope_id)
      if sid_str in scope_chains {
        chain = scope_chains[sid_str]
      }

      // Get candidate symbols by name (O(1) instead of scanning all symbols)
      candidates := []
      if ref_name in sym_name_map {
        candidates = sym_name_map[ref_name]
      }

      found := false
      for _, sc := range chain {
        for _, sym := range candidates {
          sym_line := sym["start_line"]
          if sym_line >= sc["start_line"] && sym_line <= sc["end_line"] {
            insert_resolved_reference({
              reference_id: ref_id,
              target_symbol_id: sym["id"],
              confidence: 1.0,
              resolution_kind: "direct",
            })
            ref_id_str := string(ref_id)
            resolved_set[ref_id_str] = true
            found = true
            break
          }
        }
        if found {
          break
        }
      }
    } else {
      // No scope_id — try file-level matching via name index
      candidates := []
      if ref_name in sym_name_map {
        candidates = sym_name_map[ref_name]
      }
      for _, sym := range candidates {
        if sym["kind"] != "module" {
          insert_resolved_reference({
            reference_id: ref_id,
            target_symbol_id: sym["id"],
            confidence: 0.9,
            resolution_kind: "direct",
          })
          ref_id_str := string(ref_id)
          resolved_set[ref_id_str] = true
          break
        }
      }
    }
  }
}

// --- (b) Use/import resolution ---
// For references matching an imported name, resolve to symbols that match
// the imported name across all files.
for _, f := range resolve_files {
  fid := f["id"]
  fid_str := string(fid)
  refs := file_refs_map[fid_str]
  name_map := file_import_name_map[fid_str]

  for _, ref := range refs {
    ref_id := ref["id"]
    ref_id_str := string(ref_id)
    if ref_id_str in resolved_set {
      continue
    }
    ref_name := ref["name"]

    // Check if this reference matches an imported name
    if ref_name in name_map {
      imp := name_map[ref_name]
      imp_source := imp["source"]
      imp_imported_name := ""
      if "imported_name" in imp {
        imp_imported_name = imp["imported_name"]
      }

      // Look for symbols with the imported name in all Rust files
      target_syms := symbols_by_name(imp_imported_name)
      for _, sym := range target_syms {
        // Don't resolve to a symbol in the same file (already handled in scope resolution)
        sym_file_id := nil
        if "file_id" in sym {
          sym_file_id = sym["file_id"]
        }
        if sym_file_id == fid {
          continue
        }
        insert_resolved_reference({
          reference_id: ref_id,
          target_symbol_id: sym["id"],
          confidence: 0.9,
          resolution_kind: "import",
        })
        resolved_set[ref_id_str] = true
        break
      }
    }
  }
}

// --- (c) Method resolution ---
// For "call" context references that weren't resolved above, try to match
// against methods of types in all Rust files.
for _, f := range resolve_files {
  fid := f["id"]
  fid_str := string(fid)
  refs := file_refs_map[fid_str]

  for _, ref := range refs {
    ref_id := ref["id"]
    ref_id_str := string(ref_id)
    if ref_id_str in resolved_set {
      continue
    }
    ref_ctx := ref["context"]
    ref_name := ref["name"]

    if ref_ctx == "call" || ref_ctx == "field_access" {
      // Look for methods with this name across all files
      for _, other_f := range rust_files {
        other_fid := other_f["id"]
        other_fid_str := string(other_fid)
        other_syms := file_symbols_map[other_fid_str]
        other_local_ids := file_local_sym_ids[other_fid_str]
        for _, sym := range other_syms {
          sym_id_str := string(sym["id"])
          if sym["name"] == ref_name && sym["kind"] == "method" && !(sym_id_str in other_local_ids) {
            insert_resolved_reference({
              reference_id: ref_id,
              target_symbol_id: sym["id"],
              confidence: 0.8,
              resolution_kind: "direct",
            })
            resolved_set[ref_id_str] = true
            break
          }
        }
        if ref_id_str in resolved_set {
          break
        }
      }

      // Also check struct fields for field_access
      if ref_ctx == "field_access" && !(ref_id_str in resolved_set) {
        for _, other_f := range rust_files {
          other_fid := other_f["id"]
          other_fid_str := string(other_fid)
          other_syms := file_symbols_map[other_fid_str]
          for _, sym := range other_syms {
            if sym["kind"] == "struct" || sym["kind"] == "enum" {
              members := type_members(sym["id"])
              for _, mem := range members {
                if mem["name"] == ref_name {
                  insert_resolved_reference({
                    reference_id: ref_id,
                    target_symbol_id: sym["id"],
                    confidence: 0.7,
                    resolution_kind: "direct",
                  })
                  resolved_set[ref_id_str] = true
                  break
                }
              }
              if ref_id_str in resolved_set {
                break
              }
            }
          }
          if ref_id_str in resolved_set {
            break
          }
        }
      }
    }
  }
}

// --- (d) Trait implementation matching ---
// Rust uses explicit trait implementations via `impl Trait for Type`.
// Since the extraction doesn't record the trait-type relationship directly,
// we match by checking if a type's methods satisfy a trait's required methods.
// This is heuristic but effective for same-crate analysis.
all_traits := symbols_by_kind("trait")
all_structs := symbols_by_kind("struct")
all_enums := symbols_by_kind("enum")

// Combine structs and enums as potential implementors
all_types := []
for _, st := range all_structs {
  all_types = all_types.append(st)
}
for _, en := range all_enums {
  all_types = all_types.append(en)
}

for _, trait := range all_traits {
  trait_id := trait["id"]
  trait_methods := type_members(trait_id)

  // Collect trait method names (only "method" kind, not embedded)
  trait_method_names := []
  for _, m := range trait_methods {
    if m["kind"] == "method" {
      trait_method_names = trait_method_names.append(m["name"])
    }
  }
  if len(trait_method_names) == 0 {
    continue
  }

  for _, typ := range all_types {
    if "file_id" in typ && !(string(typ["file_id"]) in resolve_fid_set) { continue }
    type_id := typ["id"]

    // Get all methods on this type (methods with parent_symbol_id == type_id)
    type_methods := db_query(
      "SELECT name FROM symbols WHERE parent_symbol_id = ? AND kind = 'method'",
      type_id,
    )
    type_method_names := {}
    for _, m := range type_methods {
      type_method_names[m["name"]] = true
    }

    // Check if type has all trait methods
    satisfies := true
    for _, method_name := range trait_method_names {
      if !(method_name in type_method_names) {
        satisfies = false
        break
      }
    }

    if satisfies {
      impl_file_id := nil
      if "file_id" in typ {
        impl_file_id = typ["file_id"]
      }

      impl_map := {
        type_symbol_id: type_id,
        interface_symbol_id: trait_id,
        kind: "explicit",
      }
      if impl_file_id != nil {
        impl_map["file_id"] = impl_file_id
      }
      insert_implementation(impl_map)
    }
  }
}

// --- (e) Call graph edge creation ---
for _, f := range resolve_files {
  fid := f["id"]
  fid_str := string(fid)
  refs := file_refs_map[fid_str]
  scopes := file_scopes_map[fid_str]
  create_call_edges(refs, resolved_set, scopes, fid, file_scope_chains[fid_str], file_sym_by_id[fid_str], nil)
}

// --- (f) Extension bindings for impl methods ---
// In Rust, methods defined in `impl Type { ... }` blocks are extension bindings.
all_methods := symbols_by_kind("method")
for _, meth := range all_methods {
  if "file_id" in meth && !(string(meth["file_id"]) in resolve_fid_set) { continue }
  parent_id := nil
  if "parent_symbol_id" in meth {
    parent_id = meth["parent_symbol_id"]
  }
  if parent_id == nil {
    continue
  }

  // Get the parent type name to use as extended_type_expr
  parent_rows := db_query(
    "SELECT name FROM symbols WHERE id = ?",
    parent_id,
  )
  if len(parent_rows) == 0 {
    continue
  }
  type_name := parent_rows[0]["name"]

  insert_extension_binding({
    member_symbol_id: meth["id"],
    extended_type_expr: type_name,
    extended_type_symbol_id: parent_id,
    kind: "method",
  })
}
