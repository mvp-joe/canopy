// Go language resolution script for Canopy.
//
// This script works entirely with relational data in SQLite — NO tree-sitter access.
// It receives these globals:
//   files_by_language, symbols_by_file, symbols_by_name, symbols_by_kind
//   references_by_file, scopes_by_file, imports_by_file
//   type_members, function_params, scope_chain, batch_scope_chains
//   insert_resolved_reference, insert_implementation,
//   insert_call_edge, insert_extension_binding
//   db_query, log

import strings

from "lib/resolve_helpers" import find_scope_for_ref, find_caller_symbol_id, create_call_edges

// ========== Helper functions (define-before-use) ==========

// find_package_name returns the package name for a file by looking for the
// "package" symbol.
func find_package_name(file_symbols) {
  for _, sym := range file_symbols {
    if sym["kind"] == "package" {
      return sym["name"]
    }
  }
  return ""
}

// strip_pointer removes leading * from a type expression.
func strip_pointer(type_expr) {
  return strings.trim(type_expr, "*")
}

// ========== Main resolution pipeline ==========

go_files := files_by_language("go")
if len(go_files) == 0 {
  // Nothing to resolve
}

// --- Build file-level data caches ---
file_symbols_map := {}
file_package_map := {}
package_files_map := {}
file_scopes_map := {}
file_imports_map := {}
file_refs_map := {}
file_scope_chains := {}
// name → [sym] index per file for O(1) lookup
file_sym_name_map := {}
// sym_id_str → sym index per file for O(1) lookup
file_sym_by_id := {}

for _, f := range go_files {
  fid := f["id"]
  fid_str := string(fid)

  syms := symbols_by_file(fid)
  file_symbols_map[fid_str] = syms

  pkg_name := find_package_name(syms)
  file_package_map[fid_str] = pkg_name

  // Group by package
  if pkg_name != "" {
    existing := []
    if pkg_name in package_files_map {
      existing = package_files_map[pkg_name]
    }
    existing = existing.append(fid)
    package_files_map[pkg_name] = existing
  }

  file_scopes_map[fid_str] = scopes_by_file(fid)
  file_imports_map[fid_str] = imports_by_file(fid)
  file_refs_map[fid_str] = references_by_file(fid)
  file_scope_chains[fid_str] = batch_scope_chains(fid)

  // Build name → [sym] index
  name_map := {}
  id_map := {}
  for _, sym := range syms {
    name := sym["name"]
    if !(name in name_map) { name_map[name] = [] }
    name_map[name] = name_map[name].append(sym)
    id_map[string(sym["id"])] = sym
  }
  file_sym_name_map[fid_str] = name_map
  file_sym_by_id[fid_str] = id_map
}

// --- Build import alias → source mapping per file ---
// file_id_str → { alias → import_map }
file_import_alias_map := {}
for _, f := range go_files {
  fid := f["id"]
  fid_str := string(fid)
  imports := file_imports_map[fid_str]
  alias_map := {}
  for _, imp := range imports {
    alias := ""
    if "local_alias" in imp {
      alias = imp["local_alias"]
    }
    if alias == "" || alias == "_" {
      // Use imported_name as the alias (default Go behavior)
      if "imported_name" in imp {
        alias = imp["imported_name"]
      }
    }
    if alias != "" && alias != "." && alias != "_" {
      alias_map[alias] = imp
    }
  }
  file_import_alias_map[fid_str] = alias_map
}

// Determine which files need resolution data written.
// files_to_resolve returns blast-radius files (or all files on first run).
resolve_files := files_to_resolve("go")

// Build a set of resolve file IDs for filtering global phases.
resolve_fid_set := {}
for _, f := range resolve_files {
  resolve_fid_set[string(f["id"])] = true
}

// Track which references have been resolved (ref_id → true)
resolved_set := {}

// --- (a) Single-file scope-based name resolution ---
for _, f := range resolve_files {
  fid := f["id"]
  fid_str := string(fid)
  refs := file_refs_map[fid_str]
  scope_chains := file_scope_chains[fid_str]
  sym_name_map := file_sym_name_map[fid_str]

  for _, ref := range refs {
    ref_id := ref["id"]
    ref_name := ref["name"]
    ref_scope_id := nil
    if "scope_id" in ref {
      ref_scope_id = ref["scope_id"]
    }

    // If the reference has a scope_id, walk the scope chain
    if ref_scope_id != nil {
      chain := []
      sid_str := string(ref_scope_id)
      if sid_str in scope_chains {
        chain = scope_chains[sid_str]
      }

      // Get candidate symbols by name (O(1) instead of scanning all symbols)
      candidates := []
      if ref_name in sym_name_map {
        candidates = sym_name_map[ref_name]
      }

      found := false
      for _, sc := range chain {
        for _, sym := range candidates {
          // Symbol must be declared in or associated with this scope
          sym_line := sym["start_line"]
          if sym_line >= sc["start_line"] && sym_line <= sc["end_line"] {
            insert_resolved_reference({
              reference_id: ref_id,
              target_symbol_id: sym["id"],
              confidence: 1.0,
              resolution_kind: "direct",
            })
            ref_id_str := string(ref_id)
            resolved_set[ref_id_str] = true
            found = true
            break
          }
        }
        if found {
          break
        }
      }
    } else {
      // No scope_id — try file-level matching via name index
      candidates := []
      if ref_name in sym_name_map {
        candidates = sym_name_map[ref_name]
      }
      for _, sym := range candidates {
        if sym["kind"] != "package" {
          insert_resolved_reference({
            reference_id: ref_id,
            target_symbol_id: sym["id"],
            confidence: 0.9,
            resolution_kind: "direct",
          })
          ref_id_str := string(ref_id)
          resolved_set[ref_id_str] = true
          break
        }
      }
    }
  }
}

// --- (b) Cross-file same-package resolution ---
for _, f := range resolve_files {
  fid := f["id"]
  fid_str := string(fid)
  pkg_name := file_package_map[fid_str]
  if pkg_name == "" {
    continue
  }

  refs := file_refs_map[fid_str]
  pkg_file_ids := []
  if pkg_name in package_files_map {
    pkg_file_ids = package_files_map[pkg_name]
  }

  for _, ref := range refs {
    ref_id := ref["id"]
    ref_id_str := string(ref_id)
    if ref_id_str in resolved_set {
      continue
    }
    ref_name := ref["name"]

    // Look in other files of the same package using name index
    found := false
    for _, other_fid := range pkg_file_ids {
      if other_fid == fid {
        continue
      }
      other_fid_str := string(other_fid)
      other_name_map := file_sym_name_map[other_fid_str]
      if !(ref_name in other_name_map) {
        continue
      }
      for _, sym := range other_name_map[ref_name] {
        if sym["kind"] != "package" {
          insert_resolved_reference({
            reference_id: ref_id,
            target_symbol_id: sym["id"],
            confidence: 1.0,
            resolution_kind: "direct",
          })
          resolved_set[ref_id_str] = true
          found = true
          break
        }
      }
      if found {
        break
      }
    }
  }
}

// --- (c) Cross-package import resolution ---
for _, f := range resolve_files {
  fid := f["id"]
  fid_str := string(fid)
  refs := file_refs_map[fid_str]
  alias_map := file_import_alias_map[fid_str]

  for _, ref := range refs {
    ref_id := ref["id"]
    ref_id_str := string(ref_id)
    if ref_id_str in resolved_set {
      continue
    }
    ref_name := ref["name"]
    ref_ctx := ref["context"]

    // Check if this reference name matches an import alias (the "fmt" in "fmt.Println")
    if ref_name in alias_map {
      // This ref is to the import itself — we don't resolve imports as symbols
      // (there's no "fmt" symbol), but mark it so we don't try further
      resolved_set[ref_id_str] = true
      continue
    }

    // For field_access refs, check if there's a preceding import-alias reference
    // on the same line. This handles "fmt.Println" where "Println" is field_access.
    if ref_ctx == "field_access" {
      // Try to find the import this field belongs to by looking at call refs
      // on the same line that match an import alias
      ref_line := ref["start_line"]
      for _, other_ref := range refs {
        other_name := other_ref["name"]
        if other_name in alias_map && other_ref["start_line"] == ref_line {
          // Found the import alias ref. Now look up symbols from the imported package.
          imp := alias_map[other_name]
          imp_source := imp["source"]
          imported_pkg_files := db_query(
            "SELECT DISTINCT f.id FROM files f JOIN symbols s ON s.file_id = f.id WHERE s.kind = 'package' AND s.name = ? AND f.language = 'go'",
            other_name,
          )
          for _, pf := range imported_pkg_files {
            pf_id := pf["id"]
            pf_syms := symbols_by_file(pf_id)
            for _, sym := range pf_syms {
              if sym["name"] == ref_name && sym["visibility"] == "public" {
                insert_resolved_reference({
                  reference_id: ref_id,
                  target_symbol_id: sym["id"],
                  confidence: 1.0,
                  resolution_kind: "import",
                })
                resolved_set[ref_id_str] = true
                break
              }
            }
            if ref_id_str in resolved_set {
              break
            }
          }
          break
        }
      }
    }
  }
}

// --- (d) Method resolution (receiver type matching) ---
for _, f := range resolve_files {
  fid := f["id"]
  fid_str := string(fid)
  pkg_name := file_package_map[fid_str]
  refs := file_refs_map[fid_str]

  pkg_file_ids := []
  if pkg_name in package_files_map {
    pkg_file_ids = package_files_map[pkg_name]
  }

  for _, ref := range refs {
    ref_id := ref["id"]
    ref_id_str := string(ref_id)
    if ref_id_str in resolved_set {
      continue
    }
    ref_ctx := ref["context"]
    ref_name := ref["name"]

    if ref_ctx == "field_access" {
      // Look for methods with this name in the same package using name index
      for _, pkg_fid := range pkg_file_ids {
        pkg_fid_str := string(pkg_fid)
        pkg_name_map := file_sym_name_map[pkg_fid_str]
        if !(ref_name in pkg_name_map) {
          continue
        }
        for _, sym := range pkg_name_map[ref_name] {
          if sym["kind"] == "method" {
            insert_resolved_reference({
              reference_id: ref_id,
              target_symbol_id: sym["id"],
              confidence: 0.8,
              resolution_kind: "direct",
            })
            resolved_set[ref_id_str] = true
            break
          }
        }
        if ref_id_str in resolved_set {
          break
        }
      }

      // Also check struct fields
      if !(ref_id_str in resolved_set) {
        for _, pkg_fid := range pkg_file_ids {
          pkg_fid_str := string(pkg_fid)
          pkg_syms := file_symbols_map[pkg_fid_str]
          for _, sym := range pkg_syms {
            if sym["kind"] == "struct" || sym["kind"] == "interface" {
              members := type_members(sym["id"])
              for _, mem := range members {
                if mem["name"] == ref_name {
                  insert_resolved_reference({
                    reference_id: ref_id,
                    target_symbol_id: sym["id"],
                    confidence: 0.7,
                    resolution_kind: "direct",
                  })
                  resolved_set[ref_id_str] = true
                  break
                }
              }
              if ref_id_str in resolved_set {
                break
              }
            }
          }
          if ref_id_str in resolved_set {
            break
          }
        }
      }
    }
  }
}

// --- (e) Interface matching (structural, implicit) ---
all_interfaces := symbols_by_kind("interface")
all_structs := symbols_by_kind("struct")

for _, iface := range all_interfaces {
  iface_id := iface["id"]
  iface_methods := type_members(iface_id)

  iface_method_names := []
  for _, m := range iface_methods {
    if m["kind"] == "method" {
      iface_method_names = iface_method_names.append(m["name"])
    }
  }
  if len(iface_method_names) == 0 {
    continue
  }

  for _, st := range all_structs {
    st_fid := string(st["file_id"])
    if !(st_fid in resolve_fid_set) { continue }
    st_id := st["id"]

    st_methods := db_query(
      "SELECT name FROM symbols WHERE parent_symbol_id = ? AND kind = 'method'",
      st_id,
    )
    st_method_names := {}
    for _, m := range st_methods {
      st_method_names[m["name"]] = true
    }

    satisfies := true
    for _, method_name := range iface_method_names {
      if !(method_name in st_method_names) {
        satisfies = false
        break
      }
    }

    if satisfies {
      impl_file_id := nil
      if "file_id" in st {
        impl_file_id = st["file_id"]
      }

      impl_map := {
        type_symbol_id: st_id,
        interface_symbol_id: iface_id,
        kind: "implicit",
      }
      if impl_file_id != nil {
        impl_map["file_id"] = impl_file_id
      }
      insert_implementation(impl_map)
    }
  }
}

// --- (f) Call graph edge creation ---
for _, f := range resolve_files {
  fid := f["id"]
  fid_str := string(fid)
  refs := file_refs_map[fid_str]
  scopes := file_scopes_map[fid_str]
  create_call_edges(refs, resolved_set, scopes, fid, file_scope_chains[fid_str], file_sym_by_id[fid_str], nil)
}

// --- (g) Extension binding for methods on types ---
all_methods := symbols_by_kind("method")
for _, meth := range all_methods {
  meth_fid := string(meth["file_id"])
  if !(meth_fid in resolve_fid_set) { continue }
  parent_id := nil
  if "parent_symbol_id" in meth {
    parent_id = meth["parent_symbol_id"]
  }
  if parent_id == nil {
    continue
  }

  params := function_params(meth["id"])
  receiver_type := ""
  for _, p := range params {
    if p["is_receiver"] {
      receiver_type = p["type_expr"]
      break
    }
  }

  if receiver_type == "" {
    continue
  }

  type_name := strip_pointer(receiver_type)

  eb_map := {
    member_symbol_id: meth["id"],
    extended_type_expr: type_name,
    extended_type_symbol_id: parent_id,
    kind: "method",
  }
  insert_extension_binding(eb_map)
}
